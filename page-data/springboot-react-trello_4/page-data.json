{"componentChunkName":"component---src-templates-post-tsx","path":"/springboot-react-trello_4/","result":{"data":{"markdownRemark":{"html":"<ol>\n<li><del>Provider 구현체 DaoAuthenticationProvider</del></li>\n<li><del>UserDetailsService 구현체 CustomUserDetailsService</del></li>\n<li><del>User Entity 및 UserPrincipal</del></li>\n<li>Authentication Handler 등록</li>\n<li>header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter</li>\n<li>AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint</li>\n<li>ErrorResponseDTO</li>\n</ol>\n<h3 id=\"authentication-handler\" style=\"position:relative;\"><a href=\"#authentication-handler\" aria-label=\"authentication handler permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"#authentication-handler\" aria-label=\"authentication handler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Authentication Handler</h3>\n<p>깜빡하고 authentication 과정이후 토큰내려주는 Handler를 안만들었었다.</p>\n<p>AbstractAuthenticationProcessingFilter는 내부적으로 인증이 성공하면 successfulAuthentication,\n실패하면 unsuccessfulAuthentication를 호출한다. 그래서 successfulAuthentication메소드안의 내용을 어떻게 커스텀하면\n토큰을 내려줄 수 있을 것 같다. </p>\n<p>우선 토큰을 만드는데 있어 JWT 라이브러리를 사용할거니까 추가해주자</p>\n<deckgo-highlight-code language=\"gradle\"  terminal=\"carbon\" >\n          <code slot=\"code\">implementation group: &#39;com.auth0&#39;, name: &#39;java-jwt&#39;, version: &#39;3.1.0&#39;</code>\n        </deckgo-highlight-code>\n<p>그리고 JWT key값, 유효기간 같은 세부설정 정보를 담는 클래스를 하나만들자</p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" >\n          <code slot=\"code\">public class JwtProperties {\n    public static final String SECRET = &quot;jinwooking&quot;;\n    public static final int EXPIRATION_TIME = 864000000; // 10 days\n    public static final String TOKEN_PREFIX = &quot;Bearer &quot;;\n    public static final String HEADER_STRING = &quot;Authorization&quot;;\n}</code>\n        </deckgo-highlight-code>\n<p>위에서 successfulAuthentication를 호출한다고 하는데 이는 또 내부적으로 successHandler의 onAuthenticationSuccess를 호출\n하는것을 알 수 있는데 이 때 successHandler를 setSuccessHandler 메소드로 바꿔줄 수 있다. AuthenticationSuccessHandler 인터페이스를\n구현 한 클래스라면 handler로 등록 가능하다 failureHandler도 마찬가지니까 한꺼번에 SecurityHandler로 작성하겠다.</p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" >\n          <code slot=\"code\">@Component\npublic class SecurityHandler implements AuthenticationSuccessHandler, AuthenticationFailureHandler {\n    @Autowired\n    ObjectMapper objectMapper;\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        if (exception instanceof AuthenticationCredentialsNotFoundException) {\n            response.setStatus(HttpStatus.UNAUTHORIZED.value());\n        } else {\n            response.setStatus(HttpStatus.FORBIDDEN.value());\n        }\n        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();\n        data.put(\n                &quot;timestamp&quot;,\n                Calendar.getInstance().getTime());\n        data.put(\n                &quot;exception&quot;,\n                exception.getMessage());\n\n\n        response.getOutputStream()\n                .println(objectMapper.writeValueAsString(data));\n\n    }\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();\n        String token = JWT.create().withSubject(userPrincipal.getEmail())\n                .withExpiresAt(new Date(System.currentTimeMillis() + JwtProperties.EXPIRATION_TIME))\n                .sign(Algorithm.HMAC512(JwtProperties.SECRET.getBytes()));\n        TokenResponseDTO tokenResponseDTO = TokenResponseDTO.builder().token(token).build();\n        PrintWriter out = response.getWriter();\n        out.print(objectMapper.writeValueAsString(tokenResponseDTO));\n        out.flush();\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>회원 정보가 있다면 이제 /api/auth/login으로 로그인을 진행하면 토큰을 발급 받을 수 있다. (생각해보니 회원가입도\n아직 안만든 상태이다...)</p>\n<h3 id=\"header인증-과정\" style=\"position:relative;\"><a href=\"#header%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95\" aria-label=\"header인증 과정 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"#header%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95\" aria-label=\"header인증 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>header인증 과정</h3>\n<p>이제 로그인으로 발급 받은 토큰을 가지고 해당 api에 접근 할 수 있는지 authorization 과정을 만들 차례이다.\nJWT방식에는 쿠키-세션같은 상태를 가지고 있지 않기 때문에 header의 Authorization 필드의 bearer token값을 매번 검사해야한다.</p>\n<p>요청이 들어오면 header 값 검증을 하는 filter를 만들어 보자.</p>\n<p>BasicAuthenticationFilter를 상속 받아 만들 예정. 기본적으로 이 필터는 authorization header를 검사하긴 하나\nBasic 방식? 으로 검사를 하기 때문에 우리가 사용하는 Bearer token방식과는 달라 새로 override해서 구현해야한다.</p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" >\n          <code slot=\"code\">public class JwtAuthorizationFilter extends BasicAuthenticationFilter {\n\n    CustomUserDetailsService customUserDetailsService;\n\n    public JwtAuthorizationFilter(AuthenticationManager authenticationManager,CustomUserDetailsService customUserDetailsService ) {\n        super(authenticationManager);\n        this.customUserDetailsService = customUserDetailsService;\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n        String header = request.getHeader(JwtProperties.HEADER_STRING);\n\n        if(header == null || !header.startsWith(JwtProperties.TOKEN_PREFIX)){\n            chain.doFilter(request,response);\n            return;\n        }\n        Authentication authentication = getUsernamePasswordAuthentication(request);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        chain.doFilter(request,response);\n    }\n    private Authentication getUsernamePasswordAuthentication(HttpServletRequest request) throws UnsupportedEncodingException {\n        String token = request.getHeader(JwtProperties.HEADER_STRING).replace(JwtProperties.TOKEN_PREFIX,&quot;&quot;);\n        String username = JWT.require(Algorithm.HMAC512(JwtProperties.SECRET.getBytes()))\n                .build()\n                .verify(token)\n                .getSubject();\n        UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);\n        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n        return authentication;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>간단히 말하면 header의 bearer 토큰을 꺼내 파싱 후 db에서 해당하는 유저가있는지 조회하는 로직을 가지고 있다. </p>\n<p>여기까지 만들었으면 기본적인 JWT 인증과정을 구현이 끝났다.\n간단히 회원가입 api와 hello api를 만들어보자</p>\n<p>회원가입 요청, 응답 DTO</p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" >\n          <code slot=\"code\">@Getter\n@NoArgsConstructor\npublic class SignupRequestDTO {\n    @Valid\n    private String email;\n    @NotEmpty\n    private String username;\n    @NotEmpty\n    private String password;\n\n    @Builder\n    public SignupRequestDTO(String email, String username, String password) {\n        this.email = email;\n        this.username = username;\n        this.password = password;\n    }\n\n    public User toEntity(PasswordEncoder passwordEncoder) {\n        return User.builder()\n                .email(this.email)\n                .password(passwordEncoder.encode(this.password))\n                .username(this.username)\n                .build();\n    }\n}\n////////\n@Getter\n@Setter\n@NoArgsConstructor\npublic class SignupResponseDTO {\n    @Valid\n    private String email;\n    private String username;\n\n    public SignupResponseDTO(User user) {\n        this.email = user.getEmail();\n        this.username = user.getUsername();\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>그리고 회원가입시켜줄 UserService </p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" >\n          <code slot=\"code\">@RequiredArgsConstructor\n@Service\npublic class UserService {\n\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n\n    @Transactional\n    public SignupResponseDTO signup (SignupRequestDTO signupRequestDTO) {\n        //중복체크\n//        User user = userRepository.findByEmail(signupRequestDTO.getEmail());\n//        if(user != null) {\n//            throw new EmailDuplicationException(user.getEmail().getValue());\n//        }\n        return new SignupResponseDTO(userRepository.save(signupRequestDTO.toEntity(passwordEncoder)));\n\n    }\n\n}</code>\n        </deckgo-highlight-code>\n<p>중간의 저 주석은 security Error 핸들링할 때 같이 처리해줄 예정이다.</p>\n<p>그리고 api controller 부분</p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" >\n          <code slot=\"code\">/// AuthController\n@RequiredArgsConstructor\n@RestController\n@RequestMapping(&quot;/api/auth&quot;)\npublic class AuthController {\n\n    private final UserService userService;\n\n    @PostMapping(&quot;/users&quot;)\n    @ResponseStatus(HttpStatus.CREATED)\n    SignupResponseDTO signup (@RequestBody @Valid SignupRequestDTO signupRequestDTO) {\n        return userService.signup(signupRequestDTO);\n    }\n}\n/// HelloController\n@RestController\n@RequestMapping(&quot;/hello&quot;)\npublic class HelloController {\n\n    @GetMapping(&quot;/&quot;)\n    public String hello () {\n        return &quot;hello&quot;;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>여기까지 작성하면 로그인 및 회원가입이 가능하고 helloController로는 토큰이 없으면 401에러를 반환할 것이다.\n다음 포스팅때 security와 controller단 error handling을 해보자.</p>\n<blockquote>\n<p>AuthorizationFilter내부에서 token으로 db를 한번씩 조회하는데 이 과정을 redis로 처리해보고싶다. 언젠간 해야징</p>\n</blockquote>","excerpt":"Provider 구현체 DaoAuthenticationProvider UserDetailsService 구현체 CustomUserDetailsService User Entity 및 UserPrincipal Authentication Handler…","tableOfContents":"<ul>\n<li><a href=\"/springboot-react-trello_4/#authentication-handler\">Authentication Handler</a></li>\n<li><a href=\"/springboot-react-trello_4/#header%EC%9D%B8%EC%A6%9D-%EA%B3%BC%EC%A0%95\">header인증 과정</a></li>\n</ul>","fields":{"slug":"/springboot-react-trello_4/"},"frontmatter":{"title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 4 )","date":"Jun 03, 2020","tags":["springboot","react"],"keywords":["trello","springboot","react"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/springboot-react-trello_4/","series":[{"slug":"/springboot-react-trello_1/","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 1 )","num":1},{"slug":"/springboot-react-trello_2/","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 2 )","num":2},{"slug":"/springboot-react-trello_3/","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 3 )","num":3},{"slug":"/springboot-react-trello_4/","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 4 )","num":4}],"lastmod":"0001-01-01"}},"staticQueryHashes":["3649515864","63159454"]}
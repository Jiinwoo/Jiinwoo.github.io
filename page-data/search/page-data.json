{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 프로젝트 생성\n```bash\nnpx create-react-app [프로젝트 명] --typescript\n```\n라우팅을 위해 다음을 설치한다.\n```bash\nnpm i react-router-dom @types/react-router-dom history\n``` \n이후 App.tsx 파일 안에 다음과 같이 라우팅 해줍니다.\n```tsx\nimport React from 'react';\nimport {Router , Route, Switch} from 'react-router-dom';\nimport {createBrowserHistory} from 'history';\nimport LoginForm from './components/LoginForm';\n\nexport const history = createBrowserHistory();\n\nfunction App() {\n  return (\n    <Router history={history}>\n      <Switch>\n        <Route component={LoginForm} to={\"/login\"} exact/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n\n```\n일반적으로 [react-router-dom]('https://reacttraining.com/react-router/web/guides/quick-start') 공식 사이트에서는 \nBrowserRouter를 사용하는데 나 같은 경우에는 조금있다가 사용할 redux 미들웨어인 thunk 함수내에서 라우팅을 하기 위해서\n추상화된 BrowserRouter 대신 기본 Router를 사용하고 history를 직접 넣었다.\n이제 로그인폼 컴포넌트를 만들어보자. \n```nashorn js\nnpm i formik\n``` \n사실 다른 form 상태관리 라이브러리는 사용해보지 않았다... 그냥 npm trend에서 많이 사용한다길래 선택한 것일 뿐\n![](formik-npm-trend.png)\n그리고 이거는 방금안 사실인데 그냥 formik만 사용하기엔 너무 밋밋해 보일 것같아서 antd를 사용해 기본적인 디자인을 주려했는데 \n아예 결합된 라이브러리가 있었다. 그래서 설치했다.\n```nashorn js\nnpm i formik-antd antd\n```\n기본적으로 form 상태 관리를 사용하지 않으면 다음과같이 코드량이 상당히 늘어나고 관리하기도 힘들다.\n\n```tsx\nimport React , {useState, ChangeEvent}from 'react';\n\nfunction LoginForm () {\n  const [email,setEmail] = useState('')\n  const [password,setPassword] = useState('')\n  const onChangeEmail = (e : ChangeEvent<HTMLInputElement>)=>{\n      setEmail(e.target.value);\n  }\n  const onChangePassword = (e : ChangeEvent<HTMLInputElement>)=>{\n      setPassword(e.target.value);\n  }\n  return (\n      <form>\n        <input value={email} onChange={onChangeEmail}/>\n        <input value={password} onChange={onChangePassword}/>\n      </form>  \n    )\n}\n``` \n기본적으로 입력 받고 상태만 관리하는데 벌써 코드량이 많아졌다.. 물론 changeMethod도 하나로 하고 useState도 하나로면 \n더 줄일 수 있겠으나 여간 귀찮은게 아니다. 그런데 formik 라이브러리를 사용하면\n```tsx\nimport { Button } from 'antd';\nimport React from 'react'\nimport { SubmitButton, Form, Input } from 'formik-antd'\nimport { Formik } from 'formik'\nimport { Link } from 'react-router-dom';\n\nexport interface ILoginValue {\n  email: string;\n  password: string;\n}\nfunction LoginForm() {\n    const initialValue: ILoginValue = {email: '', password: ''};\n    return (\n      <div style={{padding : '24px' , width: '300px'}}>\n        <Formik\n          initialValues={initialValue}\n          render={() => (\n            <Form>\n              {/* every formik-antd component must have the 'name' prop set: */}\n              <Input name='email' placeholder='이메일' />\n              <Input name='password' placeholder='패스워드' />\n              {/* the rest of the api stays as is */}\n              <SubmitButton>로그인</SubmitButton>\n            </Form>\n          )}\n          onSubmit={(value,helpers)=>{\n            setTimeout(()=>(helpers.setSubmitting(false)),200);\n            console.log(value);\n          }}/>\n        <Link to={\"/signup\"}>\n            <Button>회원가입하기</Button>\n        </Link>\n      </div>\n    )\n}\nexport default LoginForm;\n\n```\n다음과 같이 깔끔해진다. 로그인 만들었던 것 처럼 회원가입도 만들자!\n```tsx\nimport React from 'react'\nimport { SubmitButton, Form, Input } from 'formik-antd'\nimport { Formik } from 'formik'\n\nexport interface ISignupValue {\n  email: string;\n  username: string;\n  password: string;\n}\n\nfunction SignUpForm() {\n  const initialValue: ISignupValue = {email: '', username: '', password: ''}\n  return (\n    <div style={{padding : '24px' , width: '300px'}}>\n      <Formik\n        initialValues={initialValue}\n        render={() => (\n          <Form>\n            {/* every formik-antd component must have the 'name' prop set: */}\n            <Input name='email' placeholder='이메일' />\n            <Input name='username' placeholder='이름' />\n            <Input name='password' placeholder='패스워드' />\n            {/* the rest of the api stays as is */}\n            <SubmitButton>회원가입</SubmitButton>\n          </Form>\n        )}\n        onSubmit={(value,helpers)=>{\n          setTimeout(()=>(helpers.setSubmitting(false)),200);\n          console.log(value);\n        }}/>\n    </div>\n  )\n}\nexport default SignUpForm;\n\n```\n![](formik-login-form.png)\n\n그리고 라우팅도 추가해주자\n```tsx\nimport React from 'react';\nimport {Router , Route} from 'react-router-dom';\nimport {createBrowserHistory} from 'history';\nimport LoginForm from './components/LoginForm';\nimport SignUpForm from './components/SignUpForm';\n\nexport const history = createBrowserHistory();\n\nfunction App() {\n  return (\n    <Router history={history}>\n      <Route exact component={LoginForm} to={\"/login\"} />\n      <Route exact component={SignUpForm} to={\"/signup\"}/>\n    </Router>\n  );\n}\n\nexport default App;\n\n```\n기본적인 회원가입 및 로그인 컴포넌트를 완성했다.\n\n다음 포스트에서는 Spring Boot를 활용한 JWT 로그인, 회원가입을 구현해볼 예정이다. \n\n\n\n","excerpt":"프로젝트 생성 라우팅을 위해 다음을 설치한다. 이후 App.tsx 파일 안에 다음과 같이 라우팅 해줍니다. 일반적으로 react-router-dom 공식 사이트에서는 \nBrowserRouter를 사용하는데 나 같은 경우에는 조금있다가 사용할 redux…","fields":{"slug":"/springboot-react-trello_1/"},"frontmatter":{"date":"May 23, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 1 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n> Spring은 배운지 얼마안됐고 security는 더더욱 안됐습니다.\n> 정확하지 않을 수 있습니다.\n## springboot 프로젝트 생성\n\n나는 Intellij 안의 spring initializer를 사용했지만 직접 스프링이니셜라이저 사이트에\n들어가서 다운받는거랑 같다.\n![](create-project1.png)\n![](create-project2.png)\n\n지금 프로젝트에서는 이정도만 설치하자.\n\n![](create-project3.png)\n\n그리고 api, config 패키지를 다음과 같이 생성하자\n![](folder1.png)\n\n```java\n// SecurityConfig.class\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n}\n```\n그리고 어떤 요청을 해보면 다음과 같이 401에러를 내려준다.\n![](api-call1.png)\n기본적으로 모든 요청에 인증이 필요하기 때문이다. 앞으로 method를 오버라이드해서 \n설정들을 변경해볼 것이다.\n\n### 인증(Authentication)\n\n우선 로그인 과정부터 생각해 보자.\n \n\n ```json\n{\n  \"email\" : \"any@abc.com\",\n  \"password\" : \"1234\"\n}\n```\n 1. 프론트에서는 /api/auth/login 으로 위와 같은 json을 보낸다.  \n 2. Security filter chain에서 \"특정 filter\"에서 해당 정보를 AuthenticationToken으로 만들어서\n AuthenticationManager한테 전달 한 후 인증해달라고 한다.\n 3. AuthenticationManager는 현재 등록되어있는 Provider들한테 인증요청한다.  \n 4. Provider는 UserDetailService한테 DB에 존재하는지 존재하면 UserDetails를 반환해달라고 한다.\n 5.  \n \n \n 여기서 \"특정 filter\"로는 AbstractAuthenticationProcessingFilter를 상속받은 JwtAuthenticationFilter를 만들었다. 그 뒤 \nattemptAuthentication메소드를 재정의 해주면 된다.\n\n이 필터의 역활은 자기가 가지고있는 AuthenticationManager한테 (인증되지 않은)Authentication을 넘기면서 인증 해달라고 요청\n한 뒤 결과로 (인증된) Authentication을 받아서 successfulAuthentication를 호출하고 다음필터로 넘어간다. 그전에 에러가 발\n생하면 unsuccessfulAuthentication를 호출한다.\n\n우선 사용자의 로그인 정보를 담을 DTO를 생성하자\n \n```java\n@Getter\n@NoArgsConstructor\npublic class LoginRequestDTO {\n    private String email;\n    private String password;\n}\n```\n다음으로 Authentication 인터페이스의 구현체인 AbstractAuthenticationToken을 상속받은 JwtAuthenticationToken을 만들자\n```java\npublic class JwtAuthenticationToken extends AbstractAuthenticationToken {\n    private final Object principal;\n    private final String credentials;\n\n    public JwtAuthenticationToken(Collection<? extends GrantedAuthority> authorities,Object principal, String credentials) {\n        super(authorities);\n        setAuthenticated(true);\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    public JwtAuthenticationToken(Object principal, String credentials) {\n        super(null);\n        setAuthenticated(false);\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    @Override\n    public Object getCredentials() {\n        return null;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return null;\n    }\n}\n```\n그리고 attemptAuthentication 메소드를 implement 해주자.\n![](implement.png)\n```java\npublic class JwtAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n    private static final String ERROR_MESSAGE = \"Something went wrong while parsing /login request body\";\n    ObjectMapper objectMapper;\n\n    protected JwtAuthenticationFilter(ObjectMapper objectMapper) {\n        super(new AntPathRequestMatcher(\"/api/auth/login\", \"POST\"));\n        this.objectMapper = objectMapper;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n        if (!request.getMethod().equals(\"POST\")) {\n            throw new AuthenticationServiceException(\n                    \"Authentication method not supported: \" + request.getMethod());\n        }\n        try {\n            LoginRequestDTO credentials = objectMapper.readValue(request.getInputStream(),LoginRequestDTO.class);\n            JwtAuthenticationToken authenticationToken = new JwtAuthenticationToken(\n                    credentials.getEmail(),\n                    credentials.getPassword()\n            );\n            Authentication auth = this.getAuthenticationManager().authenticate(authenticationToken);\n            return auth;\n        }catch (IOException e){\n            throw new InternalAuthenticationServiceException(ERROR_MESSAGE, e);\n        }\n    }\n}\n```\n여기서 눈여겨 보아야 할 점은 JwtAuthenticationToken을 만들어서 AuthenticationManager한테 authenticate해달라고 요청 하는 \n부분이다. \nSecurityConfig에서 AuthenticationManager를 등록해야한다. 그리고 기타 설정들을 추가하자\n\n```java\n@RequiredArgsConstructor\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    private final CustomUserDetailsService customUserDetailsService;\n    private final ObjectMapper objectMapper;\n    private final SecurityHandler securityHandler;\n    private final CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.authenticationProvider(authenticationProvider());\n    }\n\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web.ignoring()\n                .antMatchers(\"/resources/**\")\n                .antMatchers(\"/css/**\")\n                .antMatchers(\"/vendor/**\")\n                .antMatchers(\"/js/**\")\n                .antMatchers(\"/favicon*/**\")\n                .antMatchers(\"/img/**\")\n        ;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.headers().frameOptions().disable();\n        http\n                // remove csrf and state in session because in jwt we do not need them\n                .csrf().disable()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // add jwt filters (1. authentication, 2. authorization)\n                .addFilter(jwtAuthenticationFilter())\n                .addFilter(jwtAuthorizationFilter())\n                .authorizeRequests()\n                // configure access rules\n                .antMatchers(HttpMethod.POST, \"/api/auth/**\").permitAll()\n                .antMatchers(\"/h2-console/**\").permitAll()\n                .antMatchers(\"/api/public/management/*\").hasRole(\"MANAGER\")\n                .antMatchers(\"/api/public/admin/*\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n                .and()\n                .exceptionHandling()\n                .authenticationEntryPoint(customAuthenticationEntryPoint);\n    }\n\n    @Bean\n    public AuthenticationProvider authenticationProvider() {\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(customUserDetailsService);\n        return daoAuthenticationProvider;\n    }\n\n    @Bean\n    public JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {\n        JwtAuthenticationFilter filter = new JwtAuthenticationFilter(objectMapper);\n        filter.setAuthenticationManager(authenticationManager());\n        filter.setAuthenticationSuccessHandler(securityHandler);\n        filter.setAuthenticationFailureHandler(securityHandler);\n        filter.afterPropertiesSet();\n        filter.setFilterProcessesUrl(\"/api/auth/signin\");\n        return filter;\n    }\n    @Bean\n    public JwtAuthorizationFilter jwtAuthorizationFilter () throws Exception {\n        JwtAuthorizationFilter filter = new JwtAuthorizationFilter(authenticationManager(),customUserDetailsService);\n        return filter;\n    }\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n여기서 만들어야할 것 \n1. Provider 구현체 DaoAuthenticationProvider\n2. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\n3. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\n4. User Entity 및 UserPrincipal \n5. UserDetailsService 구현체 CustomUserDetailsService\n6. ErrorResponseDTO\n\n는 다음포스트에서 만들자\n\n\n\n\n\n","excerpt":"Spring은 배운지 얼마안됐고 security는 더더욱 안됐습니다.\n정확하지 않을 수 있습니다. springboot 프로젝트 생성 나는 Intellij 안의 spring initializer…","fields":{"slug":"/springboot-react-trello_2/"},"frontmatter":{"date":"May 23, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 2 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}}}
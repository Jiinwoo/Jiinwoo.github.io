{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n최근에 스프링 인 액션 5 책을 보고있는데 문제점이 한두개가 아니다. 책 소개글에 이전 버전에 나타난 여러 문제들을 해결했다고\n나와있는데 전혀 그런 것 같지 않다. 가뜩이나 스프링 잘못해서 사서 공부하는데 해결하는데 시간이 더 많이 든다.. ㅠㅠ\n\n또 예제 리파지토리는 실행해보고 올린것인지 의문이 든다. \n\n우선 첫 번째로 헤맸던 것은\n```java\n@Slf4j\n@Controller\n@RequestMapping(\"/design\")\n@SessionAttributes(\"order\")\npublic class DesignTacoController {\n\n\tprivate final IngredientRepository ingredientRepo;\n\t\n\tprivate TacoRepository tacoRepo;\n\n\t@Autowired\n\tpublic DesignTacoController(\n\t\t\tIngredientRepository ingredientRepo, TacoRepository tacoRepo) {\n\t  this.ingredientRepo = ingredientRepo;\n\t  this.tacoRepo = tacoRepo;\n\t}\n\n\t@GetMapping\n\t  public String showDesignForm(Model model) {\n\t    \n\t\tList<Ingredient> ingredients = new ArrayList<>();\n\t    ingredientRepo.findAll().forEach(i -> ingredients.add(i));\n\n\t    Type[] types = Ingredient.Type.values();\n\t    for (Type type : types) {\n\t      model.addAttribute(type.toString().toLowerCase(),\n\t          filterByType(ingredients, type));\n\t    }\n\n\t    model.addAttribute(\"taco\", new Taco());\n\n\t    return \"design\";\n\t  }\n\t\n\t  private List<Ingredient> filterByType(\n\t      List<Ingredient> ingredients, Type type) {\n\t    return ingredients\n\t              .stream()\n\t              .filter(x -> x.getType().equals(type))\n\t              .collect(Collectors.toList());\n\t  }\n\n\t  @ModelAttribute(name = \"order\")\n\t  public Order order() {\n\t    return new Order();\n\t  }\n\n\t  @ModelAttribute(name = \"taco\")\n\t  public Taco taco() {\n\t    return new Taco();\n\t  }\n\n\t  @PostMapping\n\t  public String processDesign(\n\t\t\t  @Valid Taco design, \n\t\t\t  Errors errors, @ModelAttribute Order order) {\n\t\t  if (errors.hasErrors()) {\n\t\t\t return \"design\";\n\t\t  }\n\n\t\t  Taco saved = tacoRepo.save(design);\n\t\t  order.addDesign(saved);\n\n\t\t  return \"redirect:/orders/current\";\n\t  }\n\n}\n```\nhttps://github.com/Jpub/SpringInAction5 원 제작자 측이 아닌 출판사 측에서 만든 리포를 가져왔다. ch3/ch03-jdcb부분이다\n처음에 GET메소드로 thymeleaf페이지를 가져오고 submit form을 하면 재료가 전달되서 POST메소드에서 처리하는 간단한\n컨트롤러이다. \n\n하지만 POST메소드를 보면 @Valid 를 통해 검증하고 에러가 존재하면 다시 design 페이지를 반환하는데 이 때 \n재료 model객체가 사라져 다음과 같이 표시된다.\n![](https://user-images.githubusercontent.com/23472139/50333580-9e58e480-0527-11e9-801a-c5aa57def341.JPG)\n우선 이것을 해결하는 방법은 \n```java\n    @ModelAttribute\n    public void addIngredientToModel(Model model){\n        List<Ingredient> ingredients = new ArrayList<>();\n        ingredientRepo.findAll().forEach(i -> ingredients.add(i));\n\n        Type[] types = Ingredient.Type.values();\n        for (Type type : types) {\n            model.addAttribute(type.toString().toLowerCase(),\n                    filterByType(ingredients, type));\n        }\n    }\n    @GetMapping\n    public String showDesignForm(Model model) {\n        model.addAttribute(\"taco\", new Taco());\n        return \"design\";\n    }\n```\n다음과 같이 리팩토링 한다. 메소드에 @ModelAttribute를 붙임으로서 GET메소드에만 model에 적용 되지 않고 해당 컨트롤러\n전체에 적용되도록 한다.\n\n다음은 2번째 Post메소드에 문제를 보자 \n```java\n@Data\npublic class Taco {\n\n  // end::allButValidation[]\n  @NotNull\n  @Size(min=5, message=\"Name must be at least 5 characters long\")\n  // tag::allButValidation[]\n  private String name;\n  // end::allButValidation[]\n  @Size(min=1, message=\"You must choose at least 1 ingredient\")\n  // tag::allButValidation[]\n  private List<String> ingredients;\n\n}\n```\n2장 어느 부분인지는 기억이 안난다. 위를 보면 ingredients 타입으로 String을 받고있는데 책 내용을 따라가다 보면\n\n```java\n@Data\npublic class Taco {\n\t\n\tprivate Long id;\n    private Date createdAt;\n\n\t@NotNull\n\t@Size(min=5, message=\"Name must be at least 5 characters long\")\n\tprivate String name;\n\t\n\t@Size(min=1, message=\"You must choose at least 1 ingredient\")\n\tprivate List<Ingredient> ingredients;\n}\n```\n짜잔 Ingredient 타입으로 변경됐다. 여기서 문제는 기본적으로 String 배열은 스프링 컨버터가 알아서 변환해주는데\n특정 타입으로 바꿔버리면 별도의 컨버터를 등록해줘야 하는데 책에는 이런 내용이 없다. 물론 검색하면 스택오버플로우에 \n해결 방법이 있긴 있었다. ~~하지만 책은 그러면 안됐다.~~\n\n```java\n@Component\npublic class IngredientByIdConverter implements Converter<String,Ingredient> {\n\n    @Autowired\n    IngredientRepository ingredientRepository;\n\n    @Override\n    public Ingredient convert(String id) {\n        return ingredientRepository.findById(id);\n    }\n}\n```\n이 bean을 config에 추가해주면 된다.\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Autowired\n    IngredientByIdConverter ingredientByIdConverter;\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/\").setViewName(\"home\");\n    }\n\n    @Override\n    public void addFormatters(FormatterRegistry registry) {\n        registry.addConverter(ingredientByIdConverter);\n    }\n}\n\n```\n\n이제 3번째 문제를 보자.\n```java\n@Repository\npublic class JdbcTacoRepository implements TacoRepository {\n\n\tprivate JdbcTemplate jdbc;\n\n\t  public JdbcTacoRepository(JdbcTemplate jdbc) {\n\t    this.jdbc = jdbc;\n\t  }\n\n\t  @Override\n\t  public Taco save(Taco taco) {\n\t    long tacoId = saveTacoInfo(taco);\n\t    taco.setId(tacoId);\n\t    \n\t    // 스프링 Converter를 우리가 구현한 IngredientByIdConverter의 Convert() 메서드가 이때 자동 실행된다.\n\t    for (Ingredient ingredient : taco.getIngredients()) { \n\t      saveIngredientToTaco(ingredient, tacoId);\n\t    }\n\n\t    return taco;\n\t  }\n\n\t  private long saveTacoInfo(Taco taco) {\n\t    taco.setCreatedAt(new Date());\n\t    PreparedStatementCreator psc =\n\t        new PreparedStatementCreatorFactory(\n\t            \"insert into Taco (name, createdAt) values (?, ?)\",\n\t            Types.VARCHAR, Types.TIMESTAMP\n\t        ).newPreparedStatementCreator(\n\t           Arrays.asList(\n\t               taco.getName(),\n\t               new Timestamp(taco.getCreatedAt().getTime())));\n\n\t    KeyHolder keyHolder = new GeneratedKeyHolder();\n\t    jdbc.update(psc, keyHolder);\n\n\t    return keyHolder.getKey().longValue();\n\t  }\n\n\t  private void saveIngredientToTaco(\n\t          Ingredient ingredient, long tacoId) {\n\t    jdbc.update(\n\t        \"insert into Taco_Ingredients (taco, ingredient) \" +\n\t        \"values (?, ?)\",\n\t        tacoId, ingredient.getId());\n\t  }\n\n}\n```\n위 코드를 보면 IDE 에서 다음과 같이 알려준다\n![](1.png)\n에엥 난 책에있는대로 했는데 NPE가 발생한다고? 물론 출판사 깃헙 리포에도 똑같다. \n에러를 검색해보니 \n```java\n    private long saveTacoInfo(Taco taco) {\n        taco.setCreatedAt(LocalDateTime.now());\n        PreparedStatementCreatorFactory pscf = new PreparedStatementCreatorFactory(\n                \"Insert into Taco(name, createdAt) values(?,?)\", Types.VARCHAR, Types.TIMESTAMP);\n        pscf.setReturnGeneratedKeys(Boolean.TRUE); // 추가\n        PreparedStatementCreator psc = pscf.newPreparedStatementCreator(\n                Arrays.asList(taco.getName(), Timestamp.valueOf(taco.getCreatedAt())));\n        KeyHolder keyHolder = new GeneratedKeyHolder();\n        jdbc.update(psc, keyHolder);\n        return keyHolder.getKey().longValue();\n    }\n```\n다음과 같이 하면 된다.\n\n아직 책 초반인데 시간을 너무많이 잡아먹는 것 같다. 힘들다.\n","excerpt":"최근에 스프링 인 액션…","fields":{"slug":"/spring-in-action-5-3ch-bug/"},"frontmatter":{"date":"Jun 10, 2020","title":"Spring in Action 5판 3챕터 에러","tags":["Spring in action","JDBCTemplate","SpringConverter"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n## appearance\n오늘 Next.js 반응형 작업을 하던 도중 input 이 Mobile chrome 에서 이상하게 나타나는 경우가 있었다. \n여러가지 구글링을 해본결과 다음 프로퍼티를 추가해주면 된다. 설명을 보니 OS종속적인 스타일링을 해준다는 것 같다.\n```css\n.thing {\n   -webkit-appearance: none;\n   -moz-appearance:    none;\n   appearance:         none;\n}\n``` \n\n## ForwardRef \n\nNext js에서 라우팅을 담당하는 next/link 모듈이 있다. 하지만 반응형을 적용할 때 제대로 라우팅이 되지않는 현상이 발생했다.\n그 이유로 예상하는것은 Link 컴포넌트 하위에 useMediaQuery(\"(max-width : 480px)\")를 이용해 두가지로 나누어 렌더링했는데\n하나만 적용 된 걸로보아 첫 번째 새로고침 또는 페이지 렌더링을 할 때 onClick 이벤트를 붙이고 matches가 동작해\n반응형 내에서는 onClick 이벤트가 안붙는 것이다.\n\n![](1.png) ![](2.png)\n> 같은 컴포넌트이다.\n\n해결방법은 Link 컴포넌트에 passHref prop을 true로 주고 styledComponent로 Custom Anchor 태그를 만들어 적용하면 matches에 \n따라 onClick 이벤트가 붙지않고 a 태그로 라우팅이 가능하다!\n\n다음은 next/link doc에 나온 방법이다.\n```javascript\nimport Link from 'next/link'\nimport styled from 'styled-components'\n\n// This creates a custom component that wraps an <a> tag\nconst RedLink = styled.a`\n  color: red;\n`\n\nfunction NavLink({ href, name }) {\n  // Must add passHref to Link\n  return (\n    <Link href={href} passHref>\n      <RedLink>{name}</RedLink>\n    </Link>\n  )\n}\n\nexport default NavLink\n```\n\n다음과같이하면 라우팅이 onClick으로 들어가지 않고 <a> 태그로 된다\n\n","excerpt":"appearance 오늘 Next.js 반응형 작업을 하던 도중 input 이 Mobile chrome 에서 이상하게 나타나는 경우가 있었다. \n여러가지 구글링을 해본결과 다음 프로퍼티를 추가해주면 된다. 설명을 보니 OS…","fields":{"slug":"/2020-06-07TIL/"},"frontmatter":{"date":"Jun 04, 2020","title":"Ref, Mobile Chrome input css shadow수정","tags":["mobile chrome"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n1. ~~Provider 구현체 DaoAuthenticationProvider~~\n2. ~~UserDetailsService 구현체 CustomUserDetailsService~~\n3. ~~User Entity 및 UserPrincipal~~\n4. Authentication Handler 등록\n5. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\n6. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\n7. ErrorResponseDTO\n\n### Authentication Handler \n깜빡하고 authentication 과정이후 토큰내려주는 Handler를 안만들었었다.\n\nAbstractAuthenticationProcessingFilter는 내부적으로 인증이 성공하면 successfulAuthentication, \n실패하면 unsuccessfulAuthentication를 호출한다. 그래서 successfulAuthentication메소드안의 내용을 어떻게 커스텀하면\n토큰을 내려줄 수 있을 것 같다. \n\n우선 토큰을 만드는데 있어 JWT 라이브러리를 사용할거니까 추가해주자\n```gradle\nimplementation group: 'com.auth0', name: 'java-jwt', version: '3.1.0'\n```\n그리고 JWT key값, 유효기간 같은 세부설정 정보를 담는 클래스를 하나만들자\n```java\npublic class JwtProperties {\n    public static final String SECRET = \"jinwooking\";\n    public static final int EXPIRATION_TIME = 864000000; // 10 days\n    public static final String TOKEN_PREFIX = \"Bearer \";\n    public static final String HEADER_STRING = \"Authorization\";\n}\n```\n\n위에서 successfulAuthentication를 호출한다고 하는데 이는 또 내부적으로 successHandler의 onAuthenticationSuccess를 호출\n하는것을 알 수 있는데 이 때 successHandler를 setSuccessHandler 메소드로 바꿔줄 수 있다. AuthenticationSuccessHandler 인터페이스를\n구현 한 클래스라면 handler로 등록 가능하다 failureHandler도 마찬가지니까 한꺼번에 SecurityHandler로 작성하겠다.\n\n```java\n@Component\npublic class SecurityHandler implements AuthenticationSuccessHandler, AuthenticationFailureHandler {\n    @Autowired\n    ObjectMapper objectMapper;\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        if (exception instanceof AuthenticationCredentialsNotFoundException) {\n            response.setStatus(HttpStatus.UNAUTHORIZED.value());\n        } else {\n            response.setStatus(HttpStatus.FORBIDDEN.value());\n        }\n        Map<String, Object> data = new HashMap<>();\n        data.put(\n                \"timestamp\",\n                Calendar.getInstance().getTime());\n        data.put(\n                \"exception\",\n                exception.getMessage());\n\n\n        response.getOutputStream()\n                .println(objectMapper.writeValueAsString(data));\n\n    }\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();\n        String token = JWT.create().withSubject(userPrincipal.getEmail())\n                .withExpiresAt(new Date(System.currentTimeMillis() + JwtProperties.EXPIRATION_TIME))\n                .sign(Algorithm.HMAC512(JwtProperties.SECRET.getBytes()));\n        TokenResponseDTO tokenResponseDTO = TokenResponseDTO.builder().token(token).build();\n        PrintWriter out = response.getWriter();\n        out.print(objectMapper.writeValueAsString(tokenResponseDTO));\n        out.flush();\n    }\n}\n```\n\n회원 정보가 있다면 이제 /api/auth/login으로 로그인을 진행하면 토큰을 발급 받을 수 있다. (생각해보니 회원가입도 \n아직 안만든 상태이다...)\n\n\n### header인증 과정\n이제 로그인으로 발급 받은 토큰을 가지고 해당 api에 접근 할 수 있는지 authorization 과정을 만들 차례이다.\nJWT방식에는 쿠키-세션같은 상태를 가지고 있지 않기 때문에 header의 Authorization 필드의 bearer token값을 매번 검사해야한다.\n\n요청이 들어오면 header 값 검증을 하는 filter를 만들어 보자.\n\nBasicAuthenticationFilter를 상속 받아 만들 예정. 기본적으로 이 필터는 authorization header를 검사하긴 하나 \nBasic 방식? 으로 검사를 하기 때문에 우리가 사용하는 Bearer token방식과는 달라 새로 override해서 구현해야한다.\n\n```java\npublic class JwtAuthorizationFilter extends BasicAuthenticationFilter {\n\n    CustomUserDetailsService customUserDetailsService;\n\n    public JwtAuthorizationFilter(AuthenticationManager authenticationManager,CustomUserDetailsService customUserDetailsService ) {\n        super(authenticationManager);\n        this.customUserDetailsService = customUserDetailsService;\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n        String header = request.getHeader(JwtProperties.HEADER_STRING);\n\n        if(header == null || !header.startsWith(JwtProperties.TOKEN_PREFIX)){\n            chain.doFilter(request,response);\n            return;\n        }\n        Authentication authentication = getUsernamePasswordAuthentication(request);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        chain.doFilter(request,response);\n    }\n    private Authentication getUsernamePasswordAuthentication(HttpServletRequest request) throws UnsupportedEncodingException {\n        String token = request.getHeader(JwtProperties.HEADER_STRING).replace(JwtProperties.TOKEN_PREFIX,\"\");\n        String username = JWT.require(Algorithm.HMAC512(JwtProperties.SECRET.getBytes()))\n                .build()\n                .verify(token)\n                .getSubject();\n        UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);\n        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n        return authentication;\n    }\n}\n```\n간단히 말하면 header의 bearer 토큰을 꺼내 파싱 후 db에서 해당하는 유저가있는지 조회하는 로직을 가지고 있다. \n \n여기까지 만들었으면 기본적인 JWT 인증과정을 구현이 끝났다.\n간단히 회원가입 api와 hello api를 만들어보자\n\n회원가입 요청, 응답 DTO\n```java\n@Getter\n@NoArgsConstructor\npublic class SignupRequestDTO {\n    @Valid\n    private String email;\n    @NotEmpty\n    private String username;\n    @NotEmpty\n    private String password;\n\n    @Builder\n    public SignupRequestDTO(String email, String username, String password) {\n        this.email = email;\n        this.username = username;\n        this.password = password;\n    }\n\n    public User toEntity(PasswordEncoder passwordEncoder) {\n        return User.builder()\n                .email(this.email)\n                .password(passwordEncoder.encode(this.password))\n                .username(this.username)\n                .build();\n    }\n}\n////////\n@Getter\n@Setter\n@NoArgsConstructor\npublic class SignupResponseDTO {\n    @Valid\n    private String email;\n    private String username;\n\n    public SignupResponseDTO(User user) {\n        this.email = user.getEmail();\n        this.username = user.getUsername();\n    }\n}\n```\n그리고 회원가입시켜줄 UserService \n```java\n@RequiredArgsConstructor\n@Service\npublic class UserService {\n\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n\n    @Transactional\n    public SignupResponseDTO signup (SignupRequestDTO signupRequestDTO) {\n        //중복체크\n//        User user = userRepository.findByEmail(signupRequestDTO.getEmail());\n//        if(user != null) {\n//            throw new EmailDuplicationException(user.getEmail().getValue());\n//        }\n        return new SignupResponseDTO(userRepository.save(signupRequestDTO.toEntity(passwordEncoder)));\n\n    }\n\n}\n```\n중간의 저 주석은 security Error 핸들링할 때 같이 처리해줄 예정이다.\n\n그리고 api controller 부분\n```java\n/// AuthController\n@RequiredArgsConstructor\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n\n    private final UserService userService;\n\n    @PostMapping(\"/users\")\n    @ResponseStatus(HttpStatus.CREATED)\n    SignupResponseDTO signup (@RequestBody @Valid SignupRequestDTO signupRequestDTO) {\n        return userService.signup(signupRequestDTO);\n    }\n}\n/// HelloController\n@RestController\n@RequestMapping(\"/hello\")\npublic class HelloController {\n\n    @GetMapping(\"/\")\n    public String hello () {\n        return \"hello\";\n    }\n}\n```\n여기까지 작성하면 로그인 및 회원가입이 가능하고 helloController로는 토큰이 없으면 401에러를 반환할 것이다.\n다음 포스팅때 security와 controller단 error handling을 해보자.\n\n> AuthorizationFilter내부에서 token으로 db를 한번씩 조회하는데 이 과정을 redis로 처리해보고싶다. 언젠간 해야징\n","excerpt":"Provider 구현체 DaoAuthenticationProvider UserDetailsService 구현체 CustomUserDetailsService User Entity 및 UserPrincipal Authentication Handler…","fields":{"slug":"/springboot-react-trello_4/"},"frontmatter":{"date":"Jun 03, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 4 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n스프링부트와 리액트로 트렐로 클론코딩을 하던 도중 UserEntity내에 \\@NotEmpty를 사용했는데 이게 import가 안됀단다.\n![](1.png)\n>?\n \n나는 기존에 만들어둔 코드를 똑같이 한번더 만들면서 진행하는 거라 문제가 없을 줄 알았는데 한참을 삽질해서 겨우 알아냈다.\nproject를 attach해서 여러창에 띄워놔서 그런가 했는데 아니고 스프링 부트 버전 문제였다.\n\n갓 만든 프로젝트는 스프링부트 2.3.0을 사용하고 있었고 기존에 만들어둔 프로젝트 스프링부트 버전은 2.2.6이었다..\n\n[스택오버플로우](https://stackoverflow.com/questions/48614773/spring-boot-validation-annotations-valid-and-notblank-not-working)\n답변을 참고해보면\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n이걸 추가해줘야한다고 한다.  끗\n","excerpt":"스프링부트와 리액트로 트렐로 클론코딩을 하던 도중 UserEntity내에 @NotEmpty를 사용했는데 이게 import…","fields":{"slug":"/springboot-validate-error/"},"frontmatter":{"date":"May 27, 2020","title":"스프링 부트에서 @NotEmpty 찾을 수 없다고 할 때","tags":["springboot"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n저번 포스트에서 ~~귀찮아서~~ 작성하지 못했던 security 관련 설정파일들을 작성해보자.\n\n1. Provider 구현체 DaoAuthenticationProvider\n2. UserDetailsService 구현체 CustomUserDetailsService\n3. User Entity 및 UserPrincipal \n4. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\n5. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\n6. ErrorResponseDTO\n\n## Provider \n먼저 나는 Provider를 직접 구현하지 않고 DaoAuthenticationProvider를 사용할 예정이다. 이 클래스를 자세히보면\n![](dao.png)\n\nAbstractUserDetailsAuthenticationProvider를 상속해서 구현한 것을 알 수 있고 이클래스는 다시\n![](super1.png)\n\nAuthenticationProvider 인터페이스를 구현해놓은 것을 알 수 있다. \n이 인터페이스는 메소드로 authenticate메소드를 가지고 있으며\nAuthentication 을 받아 UsernamePasswordAuthenticationToken을 반환하는 역할을 한다.\n\n하지만 추상클래스이기 때문에 authentication 메소드 안에 사용하는 함수 몇몇개들을 하위에서 implement해서 사용해야한다.\n예를 들어\n![](super2.png)\n다음의 두 메소드이다. 하지만 나는 앞서 말했듯이 이걸사용해서 직접구현하지 않고 DaoAuthenticationProvider를 사용 할 것이다.\n\n> 아 그리고 이건 지금 작성하면서 안 사실인데 additionalAuthenticationChecks가 deprecated될 상황이란것이다. \n>하지만 간단하게 할거니까 무시하자..\n> ![](deprecated.png) \n\n```java\n    @Bean\n    public AuthenticationProvider authenticationProvider() {\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(customUserDetailsService);\n        return daoAuthenticationProvider;\n    }\n```\n다음과 같이 security 안에 Bean 등록을 해주고 \n```java\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.authenticationProvider(authenticationProvider());\n    }\n```\n빌더를 통해 provider를 넣어주자! 끗\n\n## UserDetails \n\nProvider는 적당히 있는 DAOauthenticationprovider를 사용했지만 나름 뭔가 커스텀한 느낌을 주기위해 UserDetailsService를 구현한 \nCustomUserDetailsService를 작성해보자.\n\n일단 현재 사용하는 Provider의 authenticate메소드를 보자. \nAbstractUserDetailsAuthenticationProvider는 현재 authenticate 메소드 안에서 retrieveUser를 호출하고\n이 retrieveUser는 하위 클래스 DaoAuthenticationProvider에서 정의 되어있고   \nretrieveUser 안에서 UserDetails 인터페이스의 loadByUserName을 호출하게 되는 것이다.\n\n사실 내가 작성해도 무슨말인지 잘모르겠다. 일단 UserDetails인터페이스를 구현한 CustomUserDetailsService를 만들자\n\n```java\n@RequiredArgsConstructor\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n    private final UserRepository userRepository;\n\n    @Override\n    @Transactional\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        User user = userRepository.findByEmail(username);\n        if(user == null){\n            throw new AuthenticationCredentialsNotFoundException(\"User not found with username or email : \" + username);\n        }\n        return UserPrincipal.create(user);\n    }\n\n}\n```\nloadUserByUsername 메소드의 역할은 username(email)을 받아서 UserDetails 인터페이스를 구현한 어떤것을 반환하면 됀다.\n그럼 구현해야 할것들이\n1. User 엔티티\n2. UserRepository\n3. UserDetails 인터페이스의 구현체 -> UserPrincipal 이라고 이름지을거임 ㅎ\n\n### User Entity\n```java\n// UserEntity\n\n@Getter\n@NoArgsConstructor\n@Table(name =\"TB_USER\")\n@Entity\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name=\"USER_ID\")\n    private Long id;\n\n    @NotBlank\n    @Column(nullable = false)\n    private String email;\n\n    @NotBlank\n    @Column(nullable = false)\n    private String username;\n\n    @NotBlank\n    @Column(nullable = false)\n    private String password;\n\n    @Builder\n    public User(String email, String password, String username) {\n        this.email = email;\n        this.password = password;\n        this.username = username;\n    }\n\n    @ManyToMany(fetch = FetchType.LAZY)\n    @JoinTable(name = \"USER_ROLE\",\n            joinColumns = @JoinColumn(name = \"user_id\"),\n            inverseJoinColumns = @JoinColumn(name = \"role_id\"))\n    private Set<Role> roles = new HashSet<>();\n\n    public void setRoles(Set<Role> roles) {\n        this.roles = roles;\n    }\n}\n \n// UserRepository\n\npublic interface UserRepository extends JpaRepository<User,Long> {\n    User findByEmail(String email);\n}\n\n// Role Entity\n\n@NoArgsConstructor\n@Table(name=\"ROLE\")\n@Getter\n@Entity\npublic class Role {\n    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name=\"ROLE_ID\")\n    private Long id;\n\n    @Enumerated(EnumType.STRING)\n    @Column\n    private RoleName name;\n\n    @Builder\n    public Role(RoleName name) {\n        this.name = name;\n    }\n}\n\n\n// Role Repository\n\npublic interface RoleRepository extends JpaRepository<Role, Long> {\n}\n```\n\n### UserPrincipal\n그리고 UserPrincipal 클래스. 이 클래스는 ValueObject 즉 값을 저장하고 쓰는 공간이라고 생각하면 쉽다.\n\n```java\n\n@Getter\npublic class UserPrincipal implements UserDetails {\n\n    private Long id;\n\n    private String username;\n\n    @JsonIgnore\n    private String email;\n\n    @JsonIgnore\n    private String password;\n\n    private Collection<? extends GrantedAuthority> authorities;\n\n    public UserPrincipal(Long id, String username, String email, String password, Collection<? extends GrantedAuthority> authorities) {\n        this.id = id;\n        this.username = username;\n        this.email = email;\n        this.password = password;\n        this.authorities = authorities;\n    }\n\n    public static UserPrincipal create(User user) {\n        List<GrantedAuthority> authorities = user.getRoles().stream().map(role ->\n                new SimpleGrantedAuthority(role.getName().name())\n        ).collect(Collectors.toList());\n\n        return new UserPrincipal(\n                user.getId(),\n                user.getUsername(),\n                user.getEmail(),\n                user.getPassword(),\n                authorities\n        );\n    }\n\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        UserPrincipal that = (UserPrincipal) o;\n        return Objects.equals(id, that.id);\n    }\n}\n```\n\n여기까지 만들고 auto import 켜둔 상태라면 CustomUserDetailsService에 빨간줄이 사라져있을 것이다.\n이제 남은거는\n\n1. ~~Provider 구현체 DaoAuthenticationProvider~~\n2. ~~UserDetailsService 구현체 CustomUserDetailsService~~\n3. ~~User Entity 및 UserPrincipal~~\n4. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\n5. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\n6. ErrorResponseDTO\n\n나머지 3개는 다음포스팅때~\n","excerpt":"저번 포스트에서 귀찮아서 작성하지 못했던 security 관련 설정파일들을 작성해보자. Provider 구현체 DaoAuthenticationProvider UserDetailsService 구현체 CustomUserDetailsService User…","fields":{"slug":"/springboot-react-trello_3/"},"frontmatter":{"date":"May 26, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 3 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div style=\"width : 100px;height:100px;background-color: #00aced\">\n    <div style=\"width:100%;padding:10px;height : 50px;background-color: #00009f\">\n        \n    </div>\n</div>\n</body>\n</html>\n\n```\n\n위와같이 코드를 작성하면 자식 div태그에서 width:100%로 부모 영역안에 위치한다고 생각 할 수 있다. 하지만 실제 결과를보면\n![](1.png)\n\n다음과같이 부모의 영역을 벗어나는 것을 알 수 있다. 이 이유는 기본 box-sizing이 content-box로 설정되어있어서인데\n해당 두번째 영역을 box-sizing : border-box; 로 설정하면 border영역까지가 width로 잡히기때문에 부모영역안으로 들어 갈 수 있다.\n![](2.png)\n","excerpt":"위와같이 코드를 작성하면 자식 div태그에서 width:100%로 부모 영역안에 위치한다고 생각 할 수 있다. 하지만 실제 결과를보면\n 다음과같이 부모의 영역을 벗어나는 것을 알 수 있다. 이 이유는 기본 box-sizing이 content-box…","fields":{"slug":"/padding-boxsizing/"},"frontmatter":{"date":"May 24, 2020","title":"자식이 부모를 벗어날 때","tags":["css","TIL"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 프로젝트 생성\n```bash\nnpx create-react-app [프로젝트 명] --typescript\n```\n위 커맨드로 프로젝트를 만들어주고 라우팅을 위해 다음을 설치한다.\n```bash\nnpm i react-router-dom @types/react-router-dom history\n``` \n이후 App.tsx 파일 안에 다음과 같이 라우팅 해줍니다.\n```tsx\nimport React from 'react';\nimport {Router , Route, Switch} from 'react-router-dom';\nimport {createBrowserHistory} from 'history';\nimport LoginForm from './components/LoginForm';\n\nexport const history = createBrowserHistory();\n\nfunction App() {\n  return (\n    <Router history={history}>\n      <Switch>\n        <Route component={LoginForm} to={\"/login\"} exact/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n\n```\n일반적으로 [react-router-dom]('https://reacttraining.com/react-router/web/guides/quick-start') 공식 사이트에서는 \nBrowserRouter를 사용하는데 나 같은 경우에는 조금있다가 사용할 redux 미들웨어인 thunk 함수내에서 라우팅을 하기 위해서\n추상화된 BrowserRouter 대신 기본 Router를 사용하고 history를 직접 넣었다.\n\n\n이제 로그인폼 컴포넌트를 만들어보자. \n```nashorn js\nnpm i formik\n``` \n사실 다른 form 상태관리 라이브러리는 사용해보지 않았다... 그냥 npm trend에서 많이 사용한다길래 선택한 것일 뿐\n![](formik-npm-trend.png)\n그리고 이거는 방금안 사실인데 그냥 formik만 사용하기엔 너무 밋밋해 보일 것같아서 antd를 사용해 기본적인 디자인을 주려했는데 \n아예 결합된 라이브러리가 있었다. 그래서 설치했다.\n```nashorn js\nnpm i formik-antd antd\n```\n기본적으로 form 상태 관리를 사용하지 않으면 다음과같이 코드량이 상당히 늘어나고 관리하기도 힘들다.\n\n```tsx\nimport React , {useState, ChangeEvent}from 'react';\n\nfunction LoginForm () {\n  const [email,setEmail] = useState('')\n  const [password,setPassword] = useState('')\n  const onChangeEmail = (e : ChangeEvent<HTMLInputElement>)=>{\n      setEmail(e.target.value);\n  }\n  const onChangePassword = (e : ChangeEvent<HTMLInputElement>)=>{\n      setPassword(e.target.value);\n  }\n  return (\n      <form>\n        <input value={email} onChange={onChangeEmail}/>\n        <input value={password} onChange={onChangePassword}/>\n      </form>  \n    )\n}\n``` \n기본적으로 입력 받고 상태만 관리하는데 벌써 코드량이 많아졌다.. 물론 changeMethod도 하나로 하고 useState도 하나로면 \n더 줄일 수 있겠으나 여간 귀찮은게 아니다. 그런데 formik 라이브러리를 사용하면\n```tsx\nimport { Button } from 'antd';\nimport React from 'react'\nimport { SubmitButton, Form, Input } from 'formik-antd'\nimport { Formik } from 'formik'\nimport { Link } from 'react-router-dom';\n\nexport interface ILoginValue {\n  email: string;\n  password: string;\n}\nfunction LoginForm() {\n    const initialValue: ILoginValue = {email: '', password: ''};\n    return (\n      <div style={{padding : '24px' , width: '300px'}}>\n        <Formik\n          initialValues={initialValue}\n          render={() => (\n            <Form>\n              {/* every formik-antd component must have the 'name' prop set: */}\n              <Input name='email' placeholder='이메일' />\n              <Input name='password' placeholder='패스워드' />\n              {/* the rest of the api stays as is */}\n              <SubmitButton>로그인</SubmitButton>\n            </Form>\n          )}\n          onSubmit={(value,helpers)=>{\n            setTimeout(()=>(helpers.setSubmitting(false)),200);\n            console.log(value);\n          }}/>\n        <Link to={\"/signup\"}>\n            <Button>회원가입하기</Button>\n        </Link>\n      </div>\n    )\n}\nexport default LoginForm;\n\n```\n다음과 같이 깔끔해진다. 로그인 만들었던 것 처럼 회원가입도 만들자!\n```tsx\nimport React from 'react'\nimport { SubmitButton, Form, Input } from 'formik-antd'\nimport { Formik } from 'formik'\n\nexport interface ISignupValue {\n  email: string;\n  username: string;\n  password: string;\n}\n\nfunction SignUpForm() {\n  const initialValue: ISignupValue = {email: '', username: '', password: ''}\n  return (\n    <div style={{padding : '24px' , width: '300px'}}>\n      <Formik\n        initialValues={initialValue}\n        render={() => (\n          <Form>\n            {/* every formik-antd component must have the 'name' prop set: */}\n            <Input name='email' placeholder='이메일' />\n            <Input name='username' placeholder='이름' />\n            <Input name='password' placeholder='패스워드' />\n            {/* the rest of the api stays as is */}\n            <SubmitButton>회원가입</SubmitButton>\n          </Form>\n        )}\n        onSubmit={(value,helpers)=>{\n          setTimeout(()=>(helpers.setSubmitting(false)),200);\n          console.log(value);\n        }}/>\n    </div>\n  )\n}\nexport default SignUpForm;\n\n```\n![](formik-login-form.png)\n\n그리고 라우팅도 추가해주자\n```tsx\nimport React from 'react';\nimport {Router , Route} from 'react-router-dom';\nimport {createBrowserHistory} from 'history';\nimport LoginForm from './components/LoginForm';\nimport SignUpForm from './components/SignUpForm';\n\nexport const history = createBrowserHistory();\n\nfunction App() {\n  return (\n    <Router history={history}>\n      <Route exact component={LoginForm} to={\"/login\"} />\n      <Route exact component={SignUpForm} to={\"/signup\"}/>\n    </Router>\n  );\n}\n\nexport default App;\n\n```\n기본적인 회원가입 및 로그인 컴포넌트를 완성했다.\n\n다음 포스트에서는 Spring Boot를 활용한 JWT 로그인, 회원가입을 구현해볼 예정이다. \n\n\n\n","excerpt":"프로젝트 생성 위 커맨드로 프로젝트를 만들어주고 라우팅을 위해 다음을 설치한다. 이후 App.tsx 파일 안에 다음과 같이 라우팅 해줍니다. 일반적으로 react-router-dom 공식 사이트에서는 \nBrowserRouter…","fields":{"slug":"/springboot-react-trello_1/"},"frontmatter":{"date":"May 23, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 1 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n> Spring은 배운지 얼마안됐고 security는 더더욱 안됐다.\n>\n> 정확하지 않을 수 있습니다.\n## springboot 프로젝트 생성\n\n나는 Intellij 안의 spring initializer를 사용했지만 직접 스프링이니셜라이저 사이트에\n들어가서 다운받는거랑 같다.\n![](create-project1.png)\n![](create-project2.png)\n\n지금 프로젝트에서는 이정도만 설치하자.\n\n![](create-project3.png)\n\n그리고 api, config 패키지를 다음과 같이 생성하자\n![](folder1.png)\n\n```java\n// SecurityConfig.class\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n}\n```\n그리고 어떤 요청을 해보면 다음과 같이 401에러를 내려준다.\n![](api-call1.png)\n기본적으로 모든 요청에 인증이 필요하기 때문이다. 앞으로 method를 오버라이드해서 \n설정들을 변경해볼 것이다.\n\n### 인증(Authentication)\n\n우선 로그인 과정부터 생각해 보자.\n \n\n ```json\n{\n  \"email\" : \"any@abc.com\",\n  \"password\" : \"1234\"\n}\n```\n 1. 프론트에서는 /api/auth/login 으로 위와 같은 json을 보낸다.  \n 2. Security filter chain에서 \"특정 filter\"에서 해당 정보를 AuthenticationToken으로 만들어서\n AuthenticationManager한테 전달 한 후 인증해달라고 한다.\n 3. AuthenticationManager는 현재 등록되어있는 Provider들한테 인증요청한다.  \n 4. Provider는 UserDetailService한테 DB에 존재하는지 존재하면 UserDetails를 반환해달라고 한다.\n 5.  \n \n \n 여기서 \"특정 filter\"로는 AbstractAuthenticationProcessingFilter를 상속받은 JwtAuthenticationFilter를 만들었다. 그 뒤 \nattemptAuthentication메소드를 재정의 해주면 된다.\n\n이 필터의 역활은 자기가 가지고있는 AuthenticationManager한테 (인증되지 않은)Authentication을 넘기면서 인증 해달라고 요청\n한 뒤 결과로 (인증된) Authentication을 받아서 successfulAuthentication를 호출하고 다음필터로 넘어간다. 그전에 에러가 \n발생하면 unsuccessfulAuthentication를 호출한다.\n\n우선 사용자의 로그인 정보를 담을 DTO를 생성하자\n \n```java\n@Getter\n@NoArgsConstructor\npublic class LoginRequestDTO {\n    private String email;\n    private String password;\n}\n```\n다음으로 Authentication 인터페이스의 구현체인 AbstractAuthenticationToken을 상속받은 JwtAuthenticationToken을 만들자\n```java\npublic class JwtAuthenticationToken extends AbstractAuthenticationToken {\n    private final Object principal;\n    private final String credentials;\n\n    public JwtAuthenticationToken(Collection<? extends GrantedAuthority> authorities,Object principal, String credentials) {\n        super(authorities);\n        setAuthenticated(true);\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    public JwtAuthenticationToken(Object principal, String credentials) {\n        super(null);\n        setAuthenticated(false);\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    @Override\n    public Object getCredentials() {\n        return null;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return null;\n    }\n}\n```\n그리고 attemptAuthentication 추상 메소드를 override해서 구현해주자.\n![](implement.png)\n```java\npublic class JwtAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n    private static final String ERROR_MESSAGE = \"Something went wrong while parsing /login request body\";\n    ObjectMapper objectMapper;\n\n    protected JwtAuthenticationFilter(ObjectMapper objectMapper) {\n        super(new AntPathRequestMatcher(\"/api/auth/login\", \"POST\"));\n        this.objectMapper = objectMapper;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n        if (!request.getMethod().equals(\"POST\")) {\n            throw new AuthenticationServiceException(\n                    \"Authentication method not supported: \" + request.getMethod());\n        }\n        try {\n            LoginRequestDTO credentials = objectMapper.readValue(request.getInputStream(),LoginRequestDTO.class);\n            JwtAuthenticationToken authenticationToken = new JwtAuthenticationToken(\n                    credentials.getEmail(),\n                    credentials.getPassword()\n            );\n            Authentication auth = this.getAuthenticationManager().authenticate(authenticationToken);\n            return auth;\n        }catch (IOException e){\n            throw new InternalAuthenticationServiceException(ERROR_MESSAGE, e);\n        }\n    }\n}\n```\n여기서 눈여겨 보아야 할 점은 JwtAuthenticationToken을 만들어서 AuthenticationManager한테 authenticate해달라고 요청 하는 \n부분이다. \nSecurityConfig에서 AuthenticationManager를 등록해야한다. 그리고 기타 설정들을 추가하자\n\n```java\n@RequiredArgsConstructor\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    private final CustomUserDetailsService customUserDetailsService;\n    private final ObjectMapper objectMapper;\n    private final SecurityHandler securityHandler;\n    private final CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.authenticationProvider(authenticationProvider());\n    }\n\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web.ignoring()\n                .antMatchers(\"/resources/**\")\n                .antMatchers(\"/css/**\")\n                .antMatchers(\"/vendor/**\")\n                .antMatchers(\"/js/**\")\n                .antMatchers(\"/favicon*/**\")\n                .antMatchers(\"/img/**\")\n        ;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.headers().frameOptions().disable();\n        http\n                // remove csrf and state in session because in jwt we do not need them\n                .csrf().disable()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // add jwt filters (1. authentication, 2. authorization)\n                .addFilter(jwtAuthenticationFilter())\n                .addFilter(jwtAuthorizationFilter())\n                .authorizeRequests()\n                // configure access rules\n                .antMatchers(HttpMethod.POST, \"/api/auth/**\").permitAll()\n                .antMatchers(\"/h2-console/**\").permitAll()\n                .antMatchers(\"/api/public/management/*\").hasRole(\"MANAGER\")\n                .antMatchers(\"/api/public/admin/*\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n                .and()\n                .exceptionHandling()\n                .authenticationEntryPoint(customAuthenticationEntryPoint);\n    }\n\n    @Bean\n    public AuthenticationProvider authenticationProvider() {\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(customUserDetailsService);\n        return daoAuthenticationProvider;\n    }\n\n    @Bean\n    public JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {\n        JwtAuthenticationFilter filter = new JwtAuthenticationFilter(objectMapper);\n        filter.setAuthenticationManager(authenticationManager());\n        filter.setAuthenticationSuccessHandler(securityHandler);\n        filter.setAuthenticationFailureHandler(securityHandler);\n        filter.afterPropertiesSet();\n        filter.setFilterProcessesUrl(\"/api/auth/signin\");\n        return filter;\n    }\n    @Bean\n    public JwtAuthorizationFilter jwtAuthorizationFilter () throws Exception {\n        JwtAuthorizationFilter filter = new JwtAuthorizationFilter(authenticationManager(),customUserDetailsService);\n        return filter;\n    }\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n> 6/6 UsernamePasswordAuthenticationFilter 대신에 이 필터의 부모클래스인 AbstractAuthenticationProcessingFilter를 상속받아\n>새로만들었는데(JwtAuthenticationFilter) 위와 같이 해주면 오류가난다 ㅠㅠ 왜냐면 기본으로 filterChain에 등록된 UsernamePasswordAuthenticationFilter\n>를 갈아끼우는게 안되기 때문! \n>대신 .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)요걸로 바꿔주면 \n>다시 작동한다. ㅠㅠ \n\n여기서 아직 구현하지 않은 것들이 있는데 만들어야 할 것들에는 \n1. Provider 구현체 DaoAuthenticationProvider\n2. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\n3. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\n4. User Entity 및 UserPrincipal \n5. UserDetailsService 구현체 CustomUserDetailsService\n6. ErrorResponseDTO\n\n는 다음포스트에서 만들자\n\n\n\n\n\n","excerpt":"Spring은 배운지 얼마안됐고 security는 더더욱 안됐다. 정확하지 않을 수 있습니다. springboot 프로젝트 생성 나는 Intellij 안의 spring initializer…","fields":{"slug":"/springboot-react-trello_2/"},"frontmatter":{"date":"May 23, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 2 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n오늘 업무를 하던 도중 styled-components v4버전 대에 build할 때 에러가 있었고 그에러가 뭐였는지 기억이 안나는데\n대충 깃헙이슈를 보니 v5 최신버전을 설치하거나 특정 type을 삭제하고 @type에 커스텀해서 추가하라는데 귀찮아서\n그냥 v5를 새로설치했다. \n\n> 사실 앞 버전 올리는데 그냥 올리면 무슨일이 터질까 매우 고민을 했지만 v5 release 문서를 보면 [\"no breaking changes!\"](https://styled-components.com/releases) \n> 라는데 큰 변화없이 속도향상을 줄수있다고 적혀있다. 그래서 그냥 업데이트 했다.\n\n그래서 설치하고 release branch에 배포했는데 html, body 등등 전역에 지정한 createGlobalStyle 메소드가 제대로 적용되지 않았다.\n\n현재 v5 styled-components의 createGlobalStyle을 next js 의 _document.tsx 내에 next/head 컴포넌트 안에서 렌더링할 때\n적용이 되지않는 문제가 있었다. \n\n여러가지 구글링을 해본 결과 _app.tsx에 createGlobalStyle을 적용해서 해결했다.\n\n> 지금 styled-components github issue 가보면 이 관련 이슈가 꽤 있는것 같다 나는 귀찮아서 그냥 넘어갔지만 얼른 누가 해결해줬으면\n>좋겠다. \n","excerpt":"오늘 업무를 하던 도중 styled-components v4버전 대에 build할 때 에러가 있었고 그에러가 뭐였는지 기억이 안나는데\n대충 깃헙이슈를 보니 v5 최신버전을 설치하거나 특정 type을 삭제하고 @type…","fields":{"slug":"/styled-components-build-error-with-nextjs/"},"frontmatter":{"date":"May 23, 2020","title":"StyledComponent v4 빌드 에러 및 nextjs에서 v5 이슈","tags":["react","styled-components","TIL"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}}}
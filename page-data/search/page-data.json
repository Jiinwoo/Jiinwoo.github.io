{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n> 본 포스팅은 니시오 히로카즈의 '코딩을 지탱하는 기술' 을 읽은 뒤 쓰는 글입니다.\n\n## 문법이란 무엇일까\n\n프로그래밍 언어를 배울 때 \"연산자 우선순위\"라는 문법을 배운다. \n'1 + 2 * 3' 같은 식에서 어느 순서대로 계산이 먼저될지 배우는 것인데 옛날에는 (1+2)*3의 형태로 계산되는 경우도 있다고 한다.\n하지만 지금 대부분은 7이 나오는데 그 이유는 각 프로그래밍 언어에서 \"+보다 *가 연산자가 높기 때문에 먼저 계산한다.\"라는 규칙을 정했기 때문이다.\n\n여기에서 알 수 있듯이 문법이란 언어 설계자가 정한 규칙이다. \n\n## 스택머신\n\n### FORTH의 스택머신\n\nFORTH는 '1과 2를 더한다'를 다음과 같이 쓴다.\n```\n    1 2 +\n```\n이렇게 쓰는데에는 스택을 사용하기 때문이다. \n\n처음에 '1'을 스택에 담고 다음 '2'도 스택에 담는다. 마지막 '+' 연산자를 만나 스택에서 2개를 꺼내 더한뒤 다시 스택에 담는다.\n최종 결과인 3이 나온다.\n\n### 지금은  1 2 + 이렇게 안쓰는데요?\n\n지금은 1 + 2 이렇게 사용하나 내부적으로는 FORTH 방식으로 실행된다!\n\n## 구문트리\n\n(1+2)\\*3 을 LISP, FORTH와 비교해보자. \n\nLISP : (\\*(+ 1 2)3)\n\nFORTH: 1 2 + 3 *\n\n각 언어별로 나타나는 형태는 다르지만 추상 구문트리는 동일하게 나온다. \n이 추상 구문트리를 전위, 중위, 후위 표기법에 따라 나타낼 뿐 의미는 동일하다. \n\n\n\n## if가 없었던 때가 있었다고?\n\n원시적인 어셈블리어에는 if문이 없다. 하지만 C언어에는 if문이 있는데 C언어에서 if문을 사용하고 어셈블리어로 컴파일 하면 어셈블리어에서 movl, cmpl 명령어를 확인 할 수 있다.\n\n이 movl명령어는 뒤의 주소로 점프하라는 명령, cmpl은 비교하는 명령어다. \n\n## if-else의 장점\n\nc언어에서 else문 없이 코드를 작성할 수 있을까? if 문과 goto를 사용하면 가능하다. 하지만 가독성 면에서 goto를 사용하는것에 비해 떨어지기 때문에 if else 구문을 사용하는 것이 낫다.\n\n\n## 반복 (while, if)\n\nwhile은 대체할 수 있을까? 어셈블리어는 movl, cmpl사용하면 가능할 것 같다. 그렇다면 C언어에서는 if와 goto를 사용하면 while문을 대체할 수 있을것같다. \n\n하지만 그렇다면 while문은 대체 왜 쓰는 것일까? 그 이유는 '읽기 쉽게', '쓰기 쉽게' 위함이다. goto는 너무 강력하기 때문에 자칫 잘못하면 프로그램이 엉망이 되어버릴 수 있기 때문에 \n사용하지 않고 while사용을 하는 것이다. \n\nfor, foreach 문도 while로 대체가 가능하다. 하지만 위와 같은 이유인 '읽기 쉽게', '쓰기 쉽게' 하기 위해 탄생한 것이다. \n\n","excerpt":"본 포스팅은 니시오 히로카즈의 '코딩을 지탱하는 기술' 을 읽은 뒤 쓰는 글입니다. 문법이란 무엇일까 프로그래밍 언어를 배울 때 \"연산자 우선순위\"라는 문법을 배운다. \n'1 + 2 *…","fields":{"slug":"/tech-of-supporting-coding_2/"},"frontmatter":{"date":"Dec 03, 2020","title":"문법, 처리흐름 제어","tags":["코딩을 지탱하는 기술"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n> 본 포스팅은 니시오 히로카즈의 '코딩을 지탱하는 기술' 을 읽은 뒤 쓰는 글입니다.\n\n## 비교를 통한 배움\n\n여러가지 언어를 배울 때 어떤점이 공통적으로 사용되고 어느 부분이 어떻게 다른지를 알게 된다면 다른 언어를 배울 때도 쉽게 익힐 수 있다고 한다.\n책의 예제에서는 참 거짓 값을 C, Ruby, Java 예시를 들었다.\n\n나는 현재 타입스크립트, 코틀린을 배우고 있으니 이 언어들의 참 거짓 값을 알아보자. \n###typescript (javascript)\n```typescript\nif(undefined || null || 0 || -0 || NaN || \"\") {\n\n}else {\n  \n}\n```\n\njavascript는 위의 7개 값이 if문 안으로 들어 갔을 때 false가 된다. \n\n### kotlin(java)\n```kotlin\nfun main() {\n    println(\"Hello, world!!!\")\n    var boo: Boolean = true\n    if(boo) {\n        println(\"asdasd\")\n    }\n}\n```\n사실 코틀린은 자바 상위 호환이기 때문에 boolean 타입 외에는 컴파일이 안된다.\n\n\n## 역사를 통한 배움\n\n언어가 가진 각 기능들은 어떠한 문제들을 해결하려고 나왔다.\n역으로 생각해 보면 어떠한 흐름을 따라 만들어졌는지 알게 된다면 해당 언어의 기능을 보다 자세히 알 수 있을것이다.\n\n\n## 프로그래밍 언어 탄생의 역사\n\n1946년 에니악, 에드삭이 나왔을 때 진공관을 일일히 연결하거나 종이에 구멍을 뚫는 등의 '기계어'를 사용했다. 하지만 이 기계어는 사람이 읽기에\n불편했으며 처리할 수 있는 데이터의 양도 적었다.\n\n### FORTRAN\n\n요즘 우리가 일반적으로 쓰는 x + y 같은 표현이 처음 사용되었던 언어가 포트란이다. 비록 초기에는 능숙한 프로그래머가 짠 기계어에 비해 효율이 \n떨어졌지만 코드량이 줄어듬과 동시에 읽기 쉬워짐에 따라 많이 사용되었다. \n \n ### 프로그램의 삼대미덕 중 하나인 게으름\n 앞날 까지 생각해서 가장 편한 방법을 선택하는 것, 즉 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 선택함.\n \n ### 무엇을 편하게 하고 싶은 것인가?, 어떤 프로그램을 편하게 만들고 싶은가?\n 모든 언어의 존재 목적은 '편리함' 이라고 했지만 각 언어가 추구하는 '편리함'은 서로 다르다. \n \n * 빠른 실행속도 : c++\n * 언어의 사양을 쉽게 파악 : Scheme\n * 다른사람이 쓴 코드를 쉽게 해석할 수 있도록 : Python\n * 웹서비스 : PHP\n * 문장 처리 : Haskell, OCaml","excerpt":"…","fields":{"slug":"/tech-of-supporting-coding_1/"},"frontmatter":{"date":"Nov 23, 2020","title":"효율적으로 언어 배우기, 프로그래밍 언어를 조감하다.","tags":["코딩을 지탱하는 기술"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n최근에 스프링 인 액션 5 책을 보고있는데 문제점이 한두개가 아니다. 책 소개글에 이전 버전에 나타난 여러 문제들을 해결했다고\r\n나와있는데 전혀 그런 것 같지 않다. 가뜩이나 스프링 잘못해서 사서 공부하는데 해결하는데 시간이 더 많이 든다.. ㅠㅠ\r\n\r\n또 예제 리파지토리는 실행해보고 올린것인지 의문이 든다. \r\n\r\n우선 첫 번째로 헤맸던 것은\r\n```java\r\n@Slf4j\r\n@Controller\r\n@RequestMapping(\"/design\")\r\n@SessionAttributes(\"order\")\r\npublic class DesignTacoController {\r\n\r\n\tprivate final IngredientRepository ingredientRepo;\r\n\t\r\n\tprivate TacoRepository tacoRepo;\r\n\r\n\t@Autowired\r\n\tpublic DesignTacoController(\r\n\t\t\tIngredientRepository ingredientRepo, TacoRepository tacoRepo) {\r\n\t  this.ingredientRepo = ingredientRepo;\r\n\t  this.tacoRepo = tacoRepo;\r\n\t}\r\n\r\n\t@GetMapping\r\n\t  public String showDesignForm(Model model) {\r\n\t    \r\n\t\tList<Ingredient> ingredients = new ArrayList<>();\r\n\t    ingredientRepo.findAll().forEach(i -> ingredients.add(i));\r\n\r\n\t    Type[] types = Ingredient.Type.values();\r\n\t    for (Type type : types) {\r\n\t      model.addAttribute(type.toString().toLowerCase(),\r\n\t          filterByType(ingredients, type));\r\n\t    }\r\n\r\n\t    model.addAttribute(\"taco\", new Taco());\r\n\r\n\t    return \"design\";\r\n\t  }\r\n\t\r\n\t  private List<Ingredient> filterByType(\r\n\t      List<Ingredient> ingredients, Type type) {\r\n\t    return ingredients\r\n\t              .stream()\r\n\t              .filter(x -> x.getType().equals(type))\r\n\t              .collect(Collectors.toList());\r\n\t  }\r\n\r\n\t  @ModelAttribute(name = \"order\")\r\n\t  public Order order() {\r\n\t    return new Order();\r\n\t  }\r\n\r\n\t  @ModelAttribute(name = \"taco\")\r\n\t  public Taco taco() {\r\n\t    return new Taco();\r\n\t  }\r\n\r\n\t  @PostMapping\r\n\t  public String processDesign(\r\n\t\t\t  @Valid Taco design, \r\n\t\t\t  Errors errors, @ModelAttribute Order order) {\r\n\t\t  if (errors.hasErrors()) {\r\n\t\t\t return \"design\";\r\n\t\t  }\r\n\r\n\t\t  Taco saved = tacoRepo.save(design);\r\n\t\t  order.addDesign(saved);\r\n\r\n\t\t  return \"redirect:/orders/current\";\r\n\t  }\r\n\r\n}\r\n```\r\nhttps://github.com/Jpub/SpringInAction5 원 제작자 측이 아닌 출판사 측에서 만든 리포를 가져왔다. ch3/ch03-jdcb부분이다\r\n처음에 GET메소드로 thymeleaf페이지를 가져오고 submit form을 하면 재료가 전달되서 POST메소드에서 처리하는 간단한\r\n컨트롤러이다. \r\n\r\n하지만 POST메소드를 보면 @Valid 를 통해 검증하고 에러가 존재하면 다시 design 페이지를 반환하는데 이 때 \r\n재료 model객체가 사라져 다음과 같이 표시된다.\r\n![](https://user-images.githubusercontent.com/23472139/50333580-9e58e480-0527-11e9-801a-c5aa57def341.JPG)\r\n우선 이것을 해결하는 방법은 \r\n```java\r\n    @ModelAttribute\r\n    public void addIngredientToModel(Model model){\r\n        List<Ingredient> ingredients = new ArrayList<>();\r\n        ingredientRepo.findAll().forEach(i -> ingredients.add(i));\r\n\r\n        Type[] types = Ingredient.Type.values();\r\n        for (Type type : types) {\r\n            model.addAttribute(type.toString().toLowerCase(),\r\n                    filterByType(ingredients, type));\r\n        }\r\n    }\r\n    @GetMapping\r\n    public String showDesignForm(Model model) {\r\n        model.addAttribute(\"taco\", new Taco());\r\n        return \"design\";\r\n    }\r\n```\r\n다음과 같이 리팩토링 한다. 메소드에 @ModelAttribute를 붙임으로서 GET메소드에만 model에 적용 되지 않고 해당 컨트롤러\r\n전체에 적용되도록 한다.\r\n\r\n이제 두번째 문제를 보자.\r\n```java\r\n@Repository\r\npublic class JdbcTacoRepository implements TacoRepository {\r\n\r\n\tprivate JdbcTemplate jdbc;\r\n\r\n\t  public JdbcTacoRepository(JdbcTemplate jdbc) {\r\n\t    this.jdbc = jdbc;\r\n\t  }\r\n\r\n\t  @Override\r\n\t  public Taco save(Taco taco) {\r\n\t    long tacoId = saveTacoInfo(taco);\r\n\t    taco.setId(tacoId);\r\n\t    \r\n\t    // 스프링 Converter를 우리가 구현한 IngredientByIdConverter의 Convert() 메서드가 이때 자동 실행된다.\r\n\t    for (Ingredient ingredient : taco.getIngredients()) { \r\n\t      saveIngredientToTaco(ingredient, tacoId);\r\n\t    }\r\n\r\n\t    return taco;\r\n\t  }\r\n\r\n\t  private long saveTacoInfo(Taco taco) {\r\n\t    taco.setCreatedAt(new Date());\r\n\t    PreparedStatementCreator psc =\r\n\t        new PreparedStatementCreatorFactory(\r\n\t            \"insert into Taco (name, createdAt) values (?, ?)\",\r\n\t            Types.VARCHAR, Types.TIMESTAMP\r\n\t        ).newPreparedStatementCreator(\r\n\t           Arrays.asList(\r\n\t               taco.getName(),\r\n\t               new Timestamp(taco.getCreatedAt().getTime())));\r\n\r\n\t    KeyHolder keyHolder = new GeneratedKeyHolder();\r\n\t    jdbc.update(psc, keyHolder);\r\n\r\n\t    return keyHolder.getKey().longValue();\r\n\t  }\r\n\r\n\t  private void saveIngredientToTaco(\r\n\t          Ingredient ingredient, long tacoId) {\r\n\t    jdbc.update(\r\n\t        \"insert into Taco_Ingredients (taco, ingredient) \" +\r\n\t        \"values (?, ?)\",\r\n\t        tacoId, ingredient.getId());\r\n\t  }\r\n\r\n}\r\n```\r\n위 코드를 보면 IDE 에서 다음과 같이 알려준다\r\n![](1.png)\r\n에엥 난 책에있는대로 했는데 NPE가 발생한다고? 물론 출판사 깃헙 리포에도 똑같다. \r\n에러를 검색해보니 \r\n```java\r\n    private long saveTacoInfo(Taco taco) {\r\n        taco.setCreatedAt(LocalDateTime.now());\r\n        PreparedStatementCreatorFactory pscf = new PreparedStatementCreatorFactory(\r\n                \"Insert into Taco(name, createdAt) values(?,?)\", Types.VARCHAR, Types.TIMESTAMP);\r\n        pscf.setReturnGeneratedKeys(Boolean.TRUE); // 추가\r\n        PreparedStatementCreator psc = pscf.newPreparedStatementCreator(\r\n                Arrays.asList(taco.getName(), Timestamp.valueOf(taco.getCreatedAt())));\r\n        KeyHolder keyHolder = new GeneratedKeyHolder();\r\n        jdbc.update(psc, keyHolder);\r\n        return keyHolder.getKey().longValue();\r\n    }\r\n```\r\n다음과 같이 하면 된다.\r\n\r\n아직 책 초반인데 시간을 너무많이 잡아먹는 것 같다. 힘들다.\r\n","excerpt":"최근에 스프링 인 액션…","fields":{"slug":"/spring-in-action-5-3ch-bug/"},"frontmatter":{"date":"Jun 10, 2020","title":"Spring in Action 5판 3챕터 에러","tags":["Spring in action","JDBCTemplate"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n\r\n## appearance\r\n오늘 Next.js 반응형 작업을 하던 도중 input 이 Mobile chrome 에서 이상하게 나타나는 경우가 있었다. \r\n여러가지 구글링을 해본결과 다음 프로퍼티를 추가해주면 된다. 설명을 보니 OS종속적인 스타일링을 해준다는 것 같다.\r\n```css\r\n.thing {\r\n   -webkit-appearance: none;\r\n   -moz-appearance:    none;\r\n   appearance:         none;\r\n}\r\n``` \r\n\r\n## ForwardRef \r\n\r\nNext js에서 라우팅을 담당하는 next/link 모듈이 있다. 하지만 반응형을 적용할 때 제대로 라우팅이 되지않는 현상이 발생했다.\r\n그 이유로 예상하는것은 Link 컴포넌트 하위에 useMediaQuery(\"(max-width : 480px)\")를 이용해 두가지로 나누어 렌더링했는데\r\n하나만 적용 된 걸로보아 첫 번째 새로고침 또는 페이지 렌더링을 할 때 onClick 이벤트를 붙이고 matches가 동작해\r\n반응형 내에서는 onClick 이벤트가 안붙는 것이다.\r\n\r\n![](1.png) ![](2.png)\r\n> 같은 컴포넌트이다.\r\n\r\n해결방법은 Link 컴포넌트에 passHref prop을 true로 주고 styledComponent로 Custom Anchor 태그를 만들어 적용하면 matches에 \r\n따라 onClick 이벤트가 붙지않고 a 태그로 라우팅이 가능하다!\r\n\r\n다음은 next/link doc에 나온 방법이다.\r\n```javascript\r\nimport Link from 'next/link'\r\nimport styled from 'styled-components'\r\n\r\n// This creates a custom component that wraps an <a> tag\r\nconst RedLink = styled.a`\r\n  color: red;\r\n`\r\n\r\nfunction NavLink({ href, name }) {\r\n  // Must add passHref to Link\r\n  return (\r\n    <Link href={href} passHref>\r\n      <RedLink>{name}</RedLink>\r\n    </Link>\r\n  )\r\n}\r\n\r\nexport default NavLink\r\n```\r\n\r\n다음과같이하면 라우팅이 onClick으로 들어가지 않고 <a> 태그로 된다\r\n\r\n","excerpt":"appearance 오늘 Next.js 반응형 작업을 하던 도중 input 이 Mobile chrome 에서 이상하게 나타나는 경우가 있었다. \n여러가지 구글링을 해본결과 다음 프로퍼티를 추가해주면 된다. 설명을 보니 OS…","fields":{"slug":"/2020-06-07TIL/"},"frontmatter":{"date":"Jun 04, 2020","title":"Ref, Mobile Chrome input css shadow수정","tags":["mobile chrome"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n1. ~~Provider 구현체 DaoAuthenticationProvider~~\r\n2. ~~UserDetailsService 구현체 CustomUserDetailsService~~\r\n3. ~~User Entity 및 UserPrincipal~~\r\n4. Authentication Handler 등록\r\n5. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\r\n6. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\r\n7. ErrorResponseDTO\r\n\r\n### Authentication Handler \r\n깜빡하고 authentication 과정이후 토큰내려주는 Handler를 안만들었었다.\r\n\r\nAbstractAuthenticationProcessingFilter는 내부적으로 인증이 성공하면 successfulAuthentication, \r\n실패하면 unsuccessfulAuthentication를 호출한다. 그래서 successfulAuthentication메소드안의 내용을 어떻게 커스텀하면\r\n토큰을 내려줄 수 있을 것 같다. \r\n\r\n우선 토큰을 만드는데 있어 JWT 라이브러리를 사용할거니까 추가해주자\r\n```gradle\r\nimplementation group: 'com.auth0', name: 'java-jwt', version: '3.1.0'\r\n```\r\n그리고 JWT key값, 유효기간 같은 세부설정 정보를 담는 클래스를 하나만들자\r\n```java\r\npublic class JwtProperties {\r\n    public static final String SECRET = \"jinwooking\";\r\n    public static final int EXPIRATION_TIME = 864000000; // 10 days\r\n    public static final String TOKEN_PREFIX = \"Bearer \";\r\n    public static final String HEADER_STRING = \"Authorization\";\r\n}\r\n```\r\n\r\n위에서 successfulAuthentication를 호출한다고 하는데 이는 또 내부적으로 successHandler의 onAuthenticationSuccess를 호출\r\n하는것을 알 수 있는데 이 때 successHandler를 setSuccessHandler 메소드로 바꿔줄 수 있다. AuthenticationSuccessHandler 인터페이스를\r\n구현 한 클래스라면 handler로 등록 가능하다 failureHandler도 마찬가지니까 한꺼번에 SecurityHandler로 작성하겠다.\r\n\r\n```java\r\n@Component\r\npublic class SecurityHandler implements AuthenticationSuccessHandler, AuthenticationFailureHandler {\r\n    @Autowired\r\n    ObjectMapper objectMapper;\r\n    @Override\r\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\r\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\r\n        if (exception instanceof AuthenticationCredentialsNotFoundException) {\r\n            response.setStatus(HttpStatus.UNAUTHORIZED.value());\r\n        } else {\r\n            response.setStatus(HttpStatus.FORBIDDEN.value());\r\n        }\r\n        Map<String, Object> data = new HashMap<>();\r\n        data.put(\r\n                \"timestamp\",\r\n                Calendar.getInstance().getTime());\r\n        data.put(\r\n                \"exception\",\r\n                exception.getMessage());\r\n\r\n\r\n        response.getOutputStream()\r\n                .println(objectMapper.writeValueAsString(data));\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\r\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\r\n        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();\r\n        String token = JWT.create().withSubject(userPrincipal.getEmail())\r\n                .withExpiresAt(new Date(System.currentTimeMillis() + JwtProperties.EXPIRATION_TIME))\r\n                .sign(Algorithm.HMAC512(JwtProperties.SECRET.getBytes()));\r\n        TokenResponseDTO tokenResponseDTO = TokenResponseDTO.builder().token(token).build();\r\n        PrintWriter out = response.getWriter();\r\n        out.print(objectMapper.writeValueAsString(tokenResponseDTO));\r\n        out.flush();\r\n    }\r\n}\r\n```\r\n\r\n회원 정보가 있다면 이제 /api/auth/login으로 로그인을 진행하면 토큰을 발급 받을 수 있다. (생각해보니 회원가입도 \r\n아직 안만든 상태이다...)\r\n\r\n\r\n### header인증 과정\r\n이제 로그인으로 발급 받은 토큰을 가지고 해당 api에 접근 할 수 있는지 authorization 과정을 만들 차례이다.\r\nJWT방식에는 쿠키-세션같은 상태를 가지고 있지 않기 때문에 header의 Authorization 필드의 bearer token값을 매번 검사해야한다.\r\n\r\n요청이 들어오면 header 값 검증을 하는 filter를 만들어 보자.\r\n\r\nBasicAuthenticationFilter를 상속 받아 만들 예정. 기본적으로 이 필터는 authorization header를 검사하긴 하나 \r\nBasic 방식? 으로 검사를 하기 때문에 우리가 사용하는 Bearer token방식과는 달라 새로 override해서 구현해야한다.\r\n\r\n```java\r\npublic class JwtAuthorizationFilter extends BasicAuthenticationFilter {\r\n\r\n    CustomUserDetailsService customUserDetailsService;\r\n\r\n    public JwtAuthorizationFilter(AuthenticationManager authenticationManager,CustomUserDetailsService customUserDetailsService ) {\r\n        super(authenticationManager);\r\n        this.customUserDetailsService = customUserDetailsService;\r\n    }\r\n\r\n    @Override\r\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\r\n        String header = request.getHeader(JwtProperties.HEADER_STRING);\r\n\r\n        if(header == null || !header.startsWith(JwtProperties.TOKEN_PREFIX)){\r\n            chain.doFilter(request,response);\r\n            return;\r\n        }\r\n        Authentication authentication = getUsernamePasswordAuthentication(request);\r\n        SecurityContextHolder.getContext().setAuthentication(authentication);\r\n        chain.doFilter(request,response);\r\n    }\r\n    private Authentication getUsernamePasswordAuthentication(HttpServletRequest request) throws UnsupportedEncodingException {\r\n        String token = request.getHeader(JwtProperties.HEADER_STRING).replace(JwtProperties.TOKEN_PREFIX,\"\");\r\n        String username = JWT.require(Algorithm.HMAC512(JwtProperties.SECRET.getBytes()))\r\n                .build()\r\n                .verify(token)\r\n                .getSubject();\r\n        UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);\r\n        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\r\n        return authentication;\r\n    }\r\n}\r\n```\r\n간단히 말하면 header의 bearer 토큰을 꺼내 파싱 후 db에서 해당하는 유저가있는지 조회하는 로직을 가지고 있다. \r\n \r\n여기까지 만들었으면 기본적인 JWT 인증과정을 구현이 끝났다.\r\n간단히 회원가입 api와 hello api를 만들어보자\r\n\r\n회원가입 요청, 응답 DTO\r\n```java\r\n@Getter\r\n@NoArgsConstructor\r\npublic class SignupRequestDTO {\r\n    @Valid\r\n    private String email;\r\n    @NotEmpty\r\n    private String username;\r\n    @NotEmpty\r\n    private String password;\r\n\r\n    @Builder\r\n    public SignupRequestDTO(String email, String username, String password) {\r\n        this.email = email;\r\n        this.username = username;\r\n        this.password = password;\r\n    }\r\n\r\n    public User toEntity(PasswordEncoder passwordEncoder) {\r\n        return User.builder()\r\n                .email(this.email)\r\n                .password(passwordEncoder.encode(this.password))\r\n                .username(this.username)\r\n                .build();\r\n    }\r\n}\r\n////////\r\n@Getter\r\n@Setter\r\n@NoArgsConstructor\r\npublic class SignupResponseDTO {\r\n    @Valid\r\n    private String email;\r\n    private String username;\r\n\r\n    public SignupResponseDTO(User user) {\r\n        this.email = user.getEmail();\r\n        this.username = user.getUsername();\r\n    }\r\n}\r\n```\r\n그리고 회원가입시켜줄 UserService \r\n```java\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class UserService {\r\n\r\n    private final UserRepository userRepository;\r\n    private final PasswordEncoder passwordEncoder;\r\n\r\n    @Transactional\r\n    public SignupResponseDTO signup (SignupRequestDTO signupRequestDTO) {\r\n        //중복체크\r\n//        User user = userRepository.findByEmail(signupRequestDTO.getEmail());\r\n//        if(user != null) {\r\n//            throw new EmailDuplicationException(user.getEmail().getValue());\r\n//        }\r\n        return new SignupResponseDTO(userRepository.save(signupRequestDTO.toEntity(passwordEncoder)));\r\n\r\n    }\r\n\r\n}\r\n```\r\n중간의 저 주석은 security Error 핸들링할 때 같이 처리해줄 예정이다.\r\n\r\n그리고 api controller 부분\r\n```java\r\n/// AuthController\r\n@RequiredArgsConstructor\r\n@RestController\r\n@RequestMapping(\"/api/auth\")\r\npublic class AuthController {\r\n\r\n    private final UserService userService;\r\n\r\n    @PostMapping(\"/users\")\r\n    @ResponseStatus(HttpStatus.CREATED)\r\n    SignupResponseDTO signup (@RequestBody @Valid SignupRequestDTO signupRequestDTO) {\r\n        return userService.signup(signupRequestDTO);\r\n    }\r\n}\r\n/// HelloController\r\n@RestController\r\n@RequestMapping(\"/hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"/\")\r\n    public String hello () {\r\n        return \"hello\";\r\n    }\r\n}\r\n```\r\n여기까지 작성하면 로그인 및 회원가입이 가능하고 helloController로는 토큰이 없으면 401에러를 반환할 것이다.\r\n다음 포스팅때 security와 controller단 error handling을 해보자.\r\n\r\n> AuthorizationFilter내부에서 token으로 db를 한번씩 조회하는데 이 과정을 redis로 처리해보고싶다. 언젠간 해야징\r\n","excerpt":"Provider 구현체 DaoAuthenticationProvider UserDetailsService 구현체 CustomUserDetailsService User Entity 및 UserPrincipal Authentication Handler…","fields":{"slug":"/springboot-react-trello_4/"},"frontmatter":{"date":"Jun 03, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 4 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n스프링부트와 리액트로 트렐로 클론코딩을 하던 도중 UserEntity내에 \\@NotEmpty를 사용했는데 이게 import가 안됀단다.\r\n![](1.png)\r\n>?\r\n \r\n나는 기존에 만들어둔 코드를 똑같이 한번더 만들면서 진행하는 거라 문제가 없을 줄 알았는데 한참을 삽질해서 겨우 알아냈다.\r\nproject를 attach해서 여러창에 띄워놔서 그런가 했는데 아니고 스프링 부트 버전 문제였다.\r\n\r\n갓 만든 프로젝트는 스프링부트 2.3.0을 사용하고 있었고 기존에 만들어둔 프로젝트 스프링부트 버전은 2.2.6이었다..\r\n\r\n[스택오버플로우](https://stackoverflow.com/questions/48614773/spring-boot-validation-annotations-valid-and-notblank-not-working)\r\n답변을 참고해보면\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-validation</artifactId>\r\n</dependency>\r\n```\r\n이걸 추가해줘야한다고 한다.  끗\r\n","excerpt":"스프링부트와 리액트로 트렐로 클론코딩을 하던 도중 UserEntity내에 @NotEmpty를 사용했는데 이게 import…","fields":{"slug":"/springboot-validate-error/"},"frontmatter":{"date":"May 27, 2020","title":"스프링 부트에서 @NotEmpty 찾을 수 없다고 할 때","tags":["springboot"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n저번 포스트에서 ~~귀찮아서~~ 작성하지 못했던 security 관련 설정파일들을 작성해보자.\r\n\r\n1. Provider 구현체 DaoAuthenticationProvider\r\n2. UserDetailsService 구현체 CustomUserDetailsService\r\n3. User Entity 및 UserPrincipal \r\n4. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\r\n5. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\r\n6. ErrorResponseDTO\r\n\r\n## Provider \r\n먼저 나는 Provider를 직접 구현하지 않고 DaoAuthenticationProvider를 사용할 예정이다. 이 클래스를 자세히보면\r\n![](dao.png)\r\n\r\nAbstractUserDetailsAuthenticationProvider를 상속해서 구현한 것을 알 수 있고 이클래스는 다시\r\n![](super1.png)\r\n\r\nAuthenticationProvider 인터페이스를 구현해놓은 것을 알 수 있다. \r\n이 인터페이스는 메소드로 authenticate메소드를 가지고 있으며\r\nAuthentication 을 받아 UsernamePasswordAuthenticationToken을 반환하는 역할을 한다.\r\n\r\n하지만 추상클래스이기 때문에 authentication 메소드 안에 사용하는 함수 몇몇개들을 하위에서 implement해서 사용해야한다.\r\n예를 들어\r\n![](super2.png)\r\n다음의 두 메소드이다. 하지만 나는 앞서 말했듯이 이걸사용해서 직접구현하지 않고 DaoAuthenticationProvider를 사용 할 것이다.\r\n\r\n> 아 그리고 이건 지금 작성하면서 안 사실인데 additionalAuthenticationChecks가 deprecated될 상황이란것이다. \r\n>하지만 간단하게 할거니까 무시하자..\r\n> ![](deprecated.png) \r\n\r\n```java\r\n    @Bean\r\n    public AuthenticationProvider authenticationProvider() {\r\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\r\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());\r\n        daoAuthenticationProvider.setUserDetailsService(customUserDetailsService);\r\n        return daoAuthenticationProvider;\r\n    }\r\n```\r\n다음과 같이 security 안에 Bean 등록을 해주고 \r\n```java\r\n    @Override\r\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\r\n        auth.authenticationProvider(authenticationProvider());\r\n    }\r\n```\r\n빌더를 통해 provider를 넣어주자! 끗\r\n\r\n## UserDetails \r\n\r\nProvider는 적당히 있는 DAOauthenticationprovider를 사용했지만 나름 뭔가 커스텀한 느낌을 주기위해 UserDetailsService를 구현한 \r\nCustomUserDetailsService를 작성해보자.\r\n\r\n일단 현재 사용하는 Provider의 authenticate메소드를 보자. \r\nAbstractUserDetailsAuthenticationProvider는 현재 authenticate 메소드 안에서 retrieveUser를 호출하고\r\n이 retrieveUser는 하위 클래스 DaoAuthenticationProvider에서 정의 되어있고   \r\nretrieveUser 안에서 UserDetails 인터페이스의 loadByUserName을 호출하게 되는 것이다.\r\n\r\n사실 내가 작성해도 무슨말인지 잘모르겠다. 일단 UserDetails인터페이스를 구현한 CustomUserDetailsService를 만들자\r\n\r\n```java\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class CustomUserDetailsService implements UserDetailsService {\r\n\r\n    private final UserRepository userRepository;\r\n\r\n    @Override\r\n    @Transactional\r\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\r\n        User user = userRepository.findByEmail(username);\r\n        if(user == null){\r\n            throw new AuthenticationCredentialsNotFoundException(\"User not found with username or email : \" + username);\r\n        }\r\n        return UserPrincipal.create(user);\r\n    }\r\n\r\n}\r\n```\r\nloadUserByUsername 메소드의 역할은 username(email)을 받아서 UserDetails 인터페이스를 구현한 어떤것을 반환하면 됀다.\r\n그럼 구현해야 할것들이\r\n1. User 엔티티\r\n2. UserRepository\r\n3. UserDetails 인터페이스의 구현체 -> UserPrincipal 이라고 이름지을거임 ㅎ\r\n\r\n### User Entity\r\n```java\r\n// UserEntity\r\n\r\n@Getter\r\n@NoArgsConstructor\r\n@Table(name =\"TB_USER\")\r\n@Entity\r\npublic class User {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name=\"USER_ID\")\r\n    private Long id;\r\n\r\n    @NotBlank\r\n    @Column(nullable = false)\r\n    private String email;\r\n\r\n    @NotBlank\r\n    @Column(nullable = false)\r\n    private String username;\r\n\r\n    @NotBlank\r\n    @Column(nullable = false)\r\n    private String password;\r\n\r\n    @Builder\r\n    public User(String email, String password, String username) {\r\n        this.email = email;\r\n        this.password = password;\r\n        this.username = username;\r\n    }\r\n\r\n    @ManyToMany(fetch = FetchType.LAZY)\r\n    @JoinTable(name = \"USER_ROLE\",\r\n            joinColumns = @JoinColumn(name = \"user_id\"),\r\n            inverseJoinColumns = @JoinColumn(name = \"role_id\"))\r\n    private Set<Role> roles = new HashSet<>();\r\n\r\n    public void setRoles(Set<Role> roles) {\r\n        this.roles = roles;\r\n    }\r\n}\r\n \r\n// UserRepository\r\n\r\npublic interface UserRepository extends JpaRepository<User,Long> {\r\n    User findByEmail(String email);\r\n}\r\n\r\n// Role Entity\r\n\r\n@NoArgsConstructor\r\n@Table(name=\"ROLE\")\r\n@Getter\r\n@Entity\r\npublic class Role {\r\n    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name=\"ROLE_ID\")\r\n    private Long id;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    @Column\r\n    private RoleName name;\r\n\r\n    @Builder\r\n    public Role(RoleName name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n\r\n// Role Repository\r\n\r\npublic interface RoleRepository extends JpaRepository<Role, Long> {\r\n}\r\n```\r\n\r\n### UserPrincipal\r\n그리고 UserPrincipal 클래스. 이 클래스는 ValueObject 즉 값을 저장하고 쓰는 공간이라고 생각하면 쉽다.\r\n\r\n```java\r\n\r\n@Getter\r\npublic class UserPrincipal implements UserDetails {\r\n\r\n    private Long id;\r\n\r\n    private String username;\r\n\r\n    @JsonIgnore\r\n    private String email;\r\n\r\n    @JsonIgnore\r\n    private String password;\r\n\r\n    private Collection<? extends GrantedAuthority> authorities;\r\n\r\n    public UserPrincipal(Long id, String username, String email, String password, Collection<? extends GrantedAuthority> authorities) {\r\n        this.id = id;\r\n        this.username = username;\r\n        this.email = email;\r\n        this.password = password;\r\n        this.authorities = authorities;\r\n    }\r\n\r\n    public static UserPrincipal create(User user) {\r\n        List<GrantedAuthority> authorities = user.getRoles().stream().map(role ->\r\n                new SimpleGrantedAuthority(role.getName().name())\r\n        ).collect(Collectors.toList());\r\n\r\n        return new UserPrincipal(\r\n                user.getId(),\r\n                user.getUsername(),\r\n                user.getEmail(),\r\n                user.getPassword(),\r\n                authorities\r\n        );\r\n    }\r\n\r\n\r\n    @Override\r\n    public Collection<? extends GrantedAuthority> getAuthorities() {\r\n        return authorities;\r\n    }\r\n\r\n    @Override\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n\r\n    @Override\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccountNonExpired() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccountNonLocked() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isCredentialsNonExpired() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(id);\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        UserPrincipal that = (UserPrincipal) o;\r\n        return Objects.equals(id, that.id);\r\n    }\r\n}\r\n```\r\n\r\n여기까지 만들고 auto import 켜둔 상태라면 CustomUserDetailsService에 빨간줄이 사라져있을 것이다.\r\n이제 남은거는\r\n\r\n1. ~~Provider 구현체 DaoAuthenticationProvider~~\r\n2. ~~UserDetailsService 구현체 CustomUserDetailsService~~\r\n3. ~~User Entity 및 UserPrincipal~~\r\n4. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\r\n5. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\r\n6. ErrorResponseDTO\r\n\r\n나머지 3개는 다음포스팅때~\r\n","excerpt":"저번 포스트에서 귀찮아서 작성하지 못했던 security 관련 설정파일들을 작성해보자. Provider 구현체 DaoAuthenticationProvider UserDetailsService 구현체 CustomUserDetailsService User…","fields":{"slug":"/springboot-react-trello_3/"},"frontmatter":{"date":"May 26, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 3 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<div style=\"width : 100px;height:100px;background-color: #00aced\">\r\n    <div style=\"width:100%;padding:10px;height : 50px;background-color: #00009f\">\r\n        \r\n    </div>\r\n</div>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n위와같이 코드를 작성하면 자식 div태그에서 width:100%로 부모 영역안에 위치한다고 생각 할 수 있다. 하지만 실제 결과를보면\r\n![](1.png)\r\n\r\n다음과같이 부모의 영역을 벗어나는 것을 알 수 있다. 이 이유는 기본 box-sizing이 content-box로 설정되어있어서인데\r\n해당 두번째 영역을 box-sizing : border-box; 로 설정하면 border영역까지가 width로 잡히기때문에 부모영역안으로 들어 갈 수 있다.\r\n![](2.png)\r\n","excerpt":"위와같이 코드를 작성하면 자식 div태그에서 width:100%로 부모 영역안에 위치한다고 생각 할 수 있다. 하지만 실제 결과를보면\n 다음과같이 부모의 영역을 벗어나는 것을 알 수 있다. 이 이유는 기본 box-sizing이 content-box…","fields":{"slug":"/padding-boxsizing/"},"frontmatter":{"date":"May 24, 2020","title":"자식이 부모를 벗어날 때","tags":["css","TIL"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n> Spring은 배운지 얼마안됐고 security는 더더욱 안됐다.\r\n>\r\n> 정확하지 않을 수 있습니다.\r\n## springboot 프로젝트 생성\r\n\r\n나는 Intellij 안의 spring initializer를 사용했지만 직접 스프링이니셜라이저 사이트에\r\n들어가서 다운받는거랑 같다.\r\n![](create-project1.png)\r\n![](create-project2.png)\r\n\r\n지금 프로젝트에서는 이정도만 설치하자.\r\n\r\n![](create-project3.png)\r\n\r\n그리고 api, config 패키지를 다음과 같이 생성하자\r\n![](folder1.png)\r\n\r\n```java\r\n// SecurityConfig.class\r\n@Configuration\r\n@EnableWebSecurity\r\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r\n}\r\n```\r\n그리고 어떤 요청을 해보면 다음과 같이 401에러를 내려준다.\r\n![](api-call1.png)\r\n기본적으로 모든 요청에 인증이 필요하기 때문이다. 앞으로 method를 오버라이드해서 \r\n설정들을 변경해볼 것이다.\r\n\r\n### 인증(Authentication)\r\n\r\n우선 로그인 과정부터 생각해 보자.\r\n \r\n\r\n ```json\r\n{\r\n  \"email\" : \"any@abc.com\",\r\n  \"password\" : \"1234\"\r\n}\r\n```\r\n 1. 프론트에서는 /api/auth/login 으로 위와 같은 json을 보낸다.  \r\n 2. Security filter chain에서 \"특정 filter\"에서 해당 정보를 AuthenticationToken으로 만들어서\r\n AuthenticationManager한테 전달 한 후 인증해달라고 한다.\r\n 3. AuthenticationManager는 현재 등록되어있는 Provider들한테 인증요청한다.  \r\n 4. Provider는 UserDetailService한테 DB에 존재하는지 존재하면 UserDetails를 반환해달라고 한다.\r\n 5.  \r\n \r\n \r\n 여기서 \"특정 filter\"로는 AbstractAuthenticationProcessingFilter를 상속받은 JwtAuthenticationFilter를 만들었다. 그 뒤 \r\nattemptAuthentication메소드를 재정의 해주면 된다.\r\n\r\n이 필터의 역활은 자기가 가지고있는 AuthenticationManager한테 (인증되지 않은)Authentication을 넘기면서 인증 해달라고 요청\r\n한 뒤 결과로 (인증된) Authentication을 받아서 successfulAuthentication를 호출하고 다음필터로 넘어간다. 그전에 에러가 \r\n발생하면 unsuccessfulAuthentication를 호출한다.\r\n\r\n우선 사용자의 로그인 정보를 담을 DTO를 생성하자\r\n \r\n```java\r\n@Getter\r\n@NoArgsConstructor\r\npublic class LoginRequestDTO {\r\n    private String email;\r\n    private String password;\r\n}\r\n```\r\n다음으로 Authentication 인터페이스의 구현체인 AbstractAuthenticationToken을 상속받은 JwtAuthenticationToken을 만들자\r\n```java\r\npublic class JwtAuthenticationToken extends AbstractAuthenticationToken {\r\n    private final Object principal;\r\n    private final String credentials;\r\n\r\n    public JwtAuthenticationToken(Collection<? extends GrantedAuthority> authorities,Object principal, String credentials) {\r\n        super(authorities);\r\n        setAuthenticated(true);\r\n        this.principal = principal;\r\n        this.credentials = credentials;\r\n    }\r\n\r\n    public JwtAuthenticationToken(Object principal, String credentials) {\r\n        super(null);\r\n        setAuthenticated(false);\r\n        this.principal = principal;\r\n        this.credentials = credentials;\r\n    }\r\n\r\n    @Override\r\n    public Object getCredentials() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Object getPrincipal() {\r\n        return null;\r\n    }\r\n}\r\n```\r\n그리고 attemptAuthentication 추상 메소드를 override해서 구현해주자.\r\n![](implement.png)\r\n```java\r\npublic class JwtAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\r\n    private static final String ERROR_MESSAGE = \"Something went wrong while parsing /login request body\";\r\n    ObjectMapper objectMapper;\r\n\r\n    protected JwtAuthenticationFilter(ObjectMapper objectMapper) {\r\n        super(new AntPathRequestMatcher(\"/api/auth/login\", \"POST\"));\r\n        this.objectMapper = objectMapper;\r\n    }\r\n\r\n    @Override\r\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\r\n        if (!request.getMethod().equals(\"POST\")) {\r\n            throw new AuthenticationServiceException(\r\n                    \"Authentication method not supported: \" + request.getMethod());\r\n        }\r\n        try {\r\n            LoginRequestDTO credentials = objectMapper.readValue(request.getInputStream(),LoginRequestDTO.class);\r\n            JwtAuthenticationToken authenticationToken = new JwtAuthenticationToken(\r\n                    credentials.getEmail(),\r\n                    credentials.getPassword()\r\n            );\r\n            Authentication auth = this.getAuthenticationManager().authenticate(authenticationToken);\r\n            return auth;\r\n        }catch (IOException e){\r\n            throw new InternalAuthenticationServiceException(ERROR_MESSAGE, e);\r\n        }\r\n    }\r\n}\r\n```\r\n여기서 눈여겨 보아야 할 점은 JwtAuthenticationToken을 만들어서 AuthenticationManager한테 authenticate해달라고 요청 하는 \r\n부분이다. \r\nSecurityConfig에서 AuthenticationManager를 등록해야한다. 그리고 기타 설정들을 추가하자\r\n\r\n```java\r\n@RequiredArgsConstructor\r\n@Configuration\r\n@EnableWebSecurity\r\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r\n    private final CustomUserDetailsService customUserDetailsService;\r\n    private final ObjectMapper objectMapper;\r\n    private final SecurityHandler securityHandler;\r\n    private final CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\r\n    @Override\r\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\r\n        auth.authenticationProvider(authenticationProvider());\r\n    }\r\n\r\n    @Override\r\n    public void configure(WebSecurity web) throws Exception {\r\n        web.ignoring()\r\n                .antMatchers(\"/resources/**\")\r\n                .antMatchers(\"/css/**\")\r\n                .antMatchers(\"/vendor/**\")\r\n                .antMatchers(\"/js/**\")\r\n                .antMatchers(\"/favicon*/**\")\r\n                .antMatchers(\"/img/**\")\r\n        ;\r\n    }\r\n\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        http.headers().frameOptions().disable();\r\n        http\r\n                // remove csrf and state in session because in jwt we do not need them\r\n                .csrf().disable()\r\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\r\n                .and()\r\n                // add jwt filters (1. authentication, 2. authorization)\r\n                .addFilter(jwtAuthenticationFilter())\r\n                .addFilter(jwtAuthorizationFilter())\r\n                .authorizeRequests()\r\n                // configure access rules\r\n                .antMatchers(HttpMethod.POST, \"/api/auth/**\").permitAll()\r\n                .antMatchers(\"/h2-console/**\").permitAll()\r\n                .antMatchers(\"/api/public/management/*\").hasRole(\"MANAGER\")\r\n                .antMatchers(\"/api/public/admin/*\").hasRole(\"ADMIN\")\r\n                .anyRequest().authenticated()\r\n                .and()\r\n                .exceptionHandling()\r\n                .authenticationEntryPoint(customAuthenticationEntryPoint);\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationProvider authenticationProvider() {\r\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\r\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());\r\n        daoAuthenticationProvider.setUserDetailsService(customUserDetailsService);\r\n        return daoAuthenticationProvider;\r\n    }\r\n\r\n    @Bean\r\n    public JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {\r\n        JwtAuthenticationFilter filter = new JwtAuthenticationFilter(objectMapper);\r\n        filter.setAuthenticationManager(authenticationManager());\r\n        filter.setAuthenticationSuccessHandler(securityHandler);\r\n        filter.setAuthenticationFailureHandler(securityHandler);\r\n        filter.afterPropertiesSet();\r\n        filter.setFilterProcessesUrl(\"/api/auth/signin\");\r\n        return filter;\r\n    }\r\n    @Bean\r\n    public JwtAuthorizationFilter jwtAuthorizationFilter () throws Exception {\r\n        JwtAuthorizationFilter filter = new JwtAuthorizationFilter(authenticationManager(),customUserDetailsService);\r\n        return filter;\r\n    }\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n}\r\n```\r\n\r\n> 6/6 UsernamePasswordAuthenticationFilter 대신에 이 필터의 부모클래스인 AbstractAuthenticationProcessingFilter를 상속받아\r\n>새로만들었는데(JwtAuthenticationFilter) 위와 같이 해주면 오류가난다 ㅠㅠ 왜냐면 기본으로 filterChain에 등록된 UsernamePasswordAuthenticationFilter\r\n>를 갈아끼우는게 안되기 때문! \r\n>대신 .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)요걸로 바꿔주면 \r\n>다시 작동한다. ㅠㅠ \r\n\r\n여기서 아직 구현하지 않은 것들이 있는데 만들어야 할 것들에는 \r\n1. Provider 구현체 DaoAuthenticationProvider\r\n2. AuthenticationEntryPoint 구현체 CustomAuthenticationEntryPoint\r\n3. header인증을 위한 BasicAuthenticationFilter 구현체 JwtAuthorizationFilter\r\n4. User Entity 및 UserPrincipal \r\n5. UserDetailsService 구현체 CustomUserDetailsService\r\n6. ErrorResponseDTO\r\n\r\n는 다음포스트에서 만들자\r\n\r\n\r\n\r\n\r\n\r\n","excerpt":"Spring은 배운지 얼마안됐고 security는 더더욱 안됐다. 정확하지 않을 수 있습니다. springboot 프로젝트 생성 나는 Intellij 안의 spring initializer…","fields":{"slug":"/springboot-react-trello_2/"},"frontmatter":{"date":"May 23, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 2 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 프로젝트 생성\r\n```bash\r\nnpx create-react-app [프로젝트 명] --typescript\r\n```\r\n위 커맨드로 프로젝트를 만들어주고 라우팅을 위해 다음을 설치한다.\r\n```bash\r\nnpm i react-router-dom @types/react-router-dom history\r\n``` \r\n이후 App.tsx 파일 안에 다음과 같이 라우팅 해줍니다.\r\n```tsx\r\nimport React from 'react';\r\nimport {Router , Route, Switch} from 'react-router-dom';\r\nimport {createBrowserHistory} from 'history';\r\nimport LoginForm from './components/LoginForm';\r\n\r\nexport const history = createBrowserHistory();\r\n\r\nfunction App() {\r\n  return (\r\n    <Router history={history}>\r\n      <Switch>\r\n        <Route component={LoginForm} to={\"/login\"} exact/>\r\n      </Switch>\r\n    </Router>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n```\r\n일반적으로 [react-router-dom]('https://reacttraining.com/react-router/web/guides/quick-start') 공식 사이트에서는 \r\nBrowserRouter를 사용하는데 나 같은 경우에는 조금있다가 사용할 redux 미들웨어인 thunk 함수내에서 라우팅을 하기 위해서\r\n추상화된 BrowserRouter 대신 기본 Router를 사용하고 history를 직접 넣었다.\r\n\r\n\r\n이제 로그인폼 컴포넌트를 만들어보자. \r\n```nashorn js\r\nnpm i formik\r\n``` \r\n사실 다른 form 상태관리 라이브러리는 사용해보지 않았다... 그냥 npm trend에서 많이 사용한다길래 선택한 것일 뿐\r\n![](formik-npm-trend.png)\r\n그리고 이거는 방금안 사실인데 그냥 formik만 사용하기엔 너무 밋밋해 보일 것같아서 antd를 사용해 기본적인 디자인을 주려했는데 \r\n아예 결합된 라이브러리가 있었다. 그래서 설치했다.\r\n```nashorn js\r\nnpm i formik-antd antd\r\n```\r\n기본적으로 form 상태 관리를 사용하지 않으면 다음과같이 코드량이 상당히 늘어나고 관리하기도 힘들다.\r\n\r\n```tsx\r\nimport React , {useState, ChangeEvent}from 'react';\r\n\r\nfunction LoginForm () {\r\n  const [email,setEmail] = useState('')\r\n  const [password,setPassword] = useState('')\r\n  const onChangeEmail = (e : ChangeEvent<HTMLInputElement>)=>{\r\n      setEmail(e.target.value);\r\n  }\r\n  const onChangePassword = (e : ChangeEvent<HTMLInputElement>)=>{\r\n      setPassword(e.target.value);\r\n  }\r\n  return (\r\n      <form>\r\n        <input value={email} onChange={onChangeEmail}/>\r\n        <input value={password} onChange={onChangePassword}/>\r\n      </form>  \r\n    )\r\n}\r\n``` \r\n기본적으로 입력 받고 상태만 관리하는데 벌써 코드량이 많아졌다.. 물론 changeMethod도 하나로 하고 useState도 하나로면 \r\n더 줄일 수 있겠으나 여간 귀찮은게 아니다. 그런데 formik 라이브러리를 사용하면\r\n```tsx\r\nimport { Button } from 'antd';\r\nimport React from 'react'\r\nimport { SubmitButton, Form, Input } from 'formik-antd'\r\nimport { Formik } from 'formik'\r\nimport { Link } from 'react-router-dom';\r\n\r\nexport interface ILoginValue {\r\n  email: string;\r\n  password: string;\r\n}\r\nfunction LoginForm() {\r\n    const initialValue: ILoginValue = {email: '', password: ''};\r\n    return (\r\n      <div style={{padding : '24px' , width: '300px'}}>\r\n        <Formik\r\n          initialValues={initialValue}\r\n          render={() => (\r\n            <Form>\r\n              {/* every formik-antd component must have the 'name' prop set: */}\r\n              <Input name='email' placeholder='이메일' />\r\n              <Input name='password' placeholder='패스워드' />\r\n              {/* the rest of the api stays as is */}\r\n              <SubmitButton>로그인</SubmitButton>\r\n            </Form>\r\n          )}\r\n          onSubmit={(value,helpers)=>{\r\n            setTimeout(()=>(helpers.setSubmitting(false)),200);\r\n            console.log(value);\r\n          }}/>\r\n        <Link to={\"/signup\"}>\r\n            <Button>회원가입하기</Button>\r\n        </Link>\r\n      </div>\r\n    )\r\n}\r\nexport default LoginForm;\r\n\r\n```\r\n다음과 같이 깔끔해진다. 로그인 만들었던 것 처럼 회원가입도 만들자!\r\n```tsx\r\nimport React from 'react'\r\nimport { SubmitButton, Form, Input } from 'formik-antd'\r\nimport { Formik } from 'formik'\r\n\r\nexport interface ISignupValue {\r\n  email: string;\r\n  username: string;\r\n  password: string;\r\n}\r\n\r\nfunction SignUpForm() {\r\n  const initialValue: ISignupValue = {email: '', username: '', password: ''}\r\n  return (\r\n    <div style={{padding : '24px' , width: '300px'}}>\r\n      <Formik\r\n        initialValues={initialValue}\r\n        render={() => (\r\n          <Form>\r\n            {/* every formik-antd component must have the 'name' prop set: */}\r\n            <Input name='email' placeholder='이메일' />\r\n            <Input name='username' placeholder='이름' />\r\n            <Input name='password' placeholder='패스워드' />\r\n            {/* the rest of the api stays as is */}\r\n            <SubmitButton>회원가입</SubmitButton>\r\n          </Form>\r\n        )}\r\n        onSubmit={(value,helpers)=>{\r\n          setTimeout(()=>(helpers.setSubmitting(false)),200);\r\n          console.log(value);\r\n        }}/>\r\n    </div>\r\n  )\r\n}\r\nexport default SignUpForm;\r\n\r\n```\r\n![](formik-login-form.png)\r\n\r\n그리고 라우팅도 추가해주자\r\n```tsx\r\nimport React from 'react';\r\nimport {Router , Route} from 'react-router-dom';\r\nimport {createBrowserHistory} from 'history';\r\nimport LoginForm from './components/LoginForm';\r\nimport SignUpForm from './components/SignUpForm';\r\n\r\nexport const history = createBrowserHistory();\r\n\r\nfunction App() {\r\n  return (\r\n    <Router history={history}>\r\n      <Route exact component={LoginForm} to={\"/login\"} />\r\n      <Route exact component={SignUpForm} to={\"/signup\"}/>\r\n    </Router>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n```\r\n기본적인 회원가입 및 로그인 컴포넌트를 완성했다.\r\n\r\n다음 포스트에서는 Spring Boot를 활용한 JWT 로그인, 회원가입을 구현해볼 예정이다. \r\n\r\n\r\n\r\n","excerpt":"프로젝트 생성 위 커맨드로 프로젝트를 만들어주고 라우팅을 위해 다음을 설치한다. 이후 App.tsx 파일 안에 다음과 같이 라우팅 해줍니다. 일반적으로 react-router-dom 공식 사이트에서는 \nBrowserRouter…","fields":{"slug":"/springboot-react-trello_1/"},"frontmatter":{"date":"May 23, 2020","title":"Spring Boot, React 사용해 Trello 클론코딩하기 ( 1 )","tags":["springboot","react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n오늘 업무를 하던 도중 styled-components v4버전 대에 build할 때 에러가 있었고 그에러가 뭐였는지 기억이 안나는데\r\n대충 깃헙이슈를 보니 v5 최신버전을 설치하거나 특정 type을 삭제하고 @type에 커스텀해서 추가하라는데 귀찮아서\r\n그냥 v5를 새로설치했다. \r\n\r\n> 사실 앞 버전 올리는데 그냥 올리면 무슨일이 터질까 매우 고민을 했지만 v5 release 문서를 보면 [\"no breaking changes!\"](https://styled-components.com/releases) \r\n> 라는데 큰 변화없이 속도향상을 줄수있다고 적혀있다. 그래서 그냥 업데이트 했다.\r\n\r\n그래서 설치하고 release branch에 배포했는데 html, body 등등 전역에 지정한 createGlobalStyle 메소드가 제대로 적용되지 않았다.\r\n\r\n현재 v5 styled-components의 createGlobalStyle을 next js 의 _document.tsx 내에 next/head 컴포넌트 안에서 렌더링할 때\r\n적용이 되지않는 문제가 있었다. \r\n\r\n여러가지 구글링을 해본 결과 _app.tsx에 createGlobalStyle을 적용해서 해결했다.\r\n\r\n> 지금 styled-components github issue 가보면 이 관련 이슈가 꽤 있는것 같다 나는 귀찮아서 그냥 넘어갔지만 얼른 누가 해결해줬으면\r\n>좋겠다. \r\n","excerpt":"오늘 업무를 하던 도중 styled-components v4버전 대에 build할 때 에러가 있었고 그에러가 뭐였는지 기억이 안나는데\n대충 깃헙이슈를 보니 v5 최신버전을 설치하거나 특정 type을 삭제하고 @type…","fields":{"slug":"/styled-components-build-error-with-nextjs/"},"frontmatter":{"date":"May 23, 2020","title":"StyledComponent v4 빌드 에러 및 nextjs에서 v5 이슈","tags":["react","styled-components","TIL"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}